<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Î£Ï‡ÎµÎ´Î¹Î±ÏƒÏ„Î®Ï‚ Î”Î¹Î±Î´ÏÎ¿Î¼Î®Ï‚ Î¼Îµ Î‘Î½Î±Î¶Î®Ï„Î·ÏƒÎ·</title>
    
    <!-- MapTiler SDK CSS -->
    <link href="https://cdn.maptiler.com/maptiler-sdk-js/v2.0.3/maptiler-sdk.css" rel="stylesheet" />
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- LZ-String for URL compression -->
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
    
    <style>
        /* Custom styles for the application */
        body {
            font-family: 'Poppins', sans-serif;
            overflow: hidden; /* Prevent body scroll */
        }
        
        #map {
            height: 100%;
            width: 100%;
            cursor: crosshair;
        }
        
        /* Styling for the pins on the map */
        .pin-icon {
            background: #3B82F6;
            border: 3px solid white;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .pin-icon.start {
            background: #10B981;
        }
        
        .pin-icon.start.flag {
            font-size: 18px;
        }
        
        .pin-icon.selected {
            border-color: #F59E0B;
            border-width: 4px;
        }

        /* Loading spinner animation */
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3B82F6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        /* In-search-bar spinner */
        .search-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3B82F6;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Fade out animation for messages */
        .message-fade {
            animation: fadeOut 5s forwards;
        }
        
        @keyframes fadeOut {
            0% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; display: none; }
        }

        /* Custom scrollbar for the stats panel */
        #stats-panel::-webkit-scrollbar {
            width: 8px;
        }
        #stats-panel::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        #stats-panel::-webkit-scrollbar-thumb {
            background: #a8a8a8;
            border-radius: 4px;
        }
        #stats-panel::-webkit-scrollbar-thumb:hover {
            background: #888;
        }

        /* Custom scrollbar for the address list */
        #addressList::-webkit-scrollbar {
            width: 6px;
        }
        #addressList::-webkit-scrollbar-track {
            background: transparent;
        }
        #addressList::-webkit-scrollbar-thumb {
            background: #a8a8a8;
            border-radius: 3px;
        }
        #addressList::-webkit-scrollbar-thumb:hover {
            background: #888;
        }
        #addressList {
            max-height: min(45vh, 440px); /* Scalable max-height */
        }

        /* Common button style */
        .action-button {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(200, 200, 200, 0.4);
            border-radius: 0.5rem;
            padding: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .action-button:hover:not(:disabled) {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            transform: translateY(-1px);
        }
        
        /* Menu panel styles */
        .menu-panel {
            position: absolute;
            top: 5.5rem; /* Adjusted for new button layout */
            right: 1rem;
            z-index: 2000;
            padding: 1rem;
            min-width: 300px;
        }
        
        .menu-hidden {
            display: none;
        }

        /* --- STYLES FOR GLASS PANELS (BOTTOM & MENU) --- */
        .glass-panel {
            background: rgba(255, 255, 255, 0.1); /* Increased transparency */
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(200, 200, 200, 0.4);
        }

        #bottomPanel {
            height: 45vh; /* Default height for mobile */
            border-top-width: 1px; /* Keep only top border */
            border-left-width: 0; border-right-width: 0; border-bottom-width: 0;
            transform: translateY(100%);
            transition: transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 -4px 30px rgba(0,0,0,0.1);
        }
        
        @media (min-width: 1024px) {
            #bottomPanel {
                height: 25vh;
            }
        }
        
        #bottomPanel.is-visible {
            transform: translateY(0);
        }

        /* Tooltip styles for estimated duration and toggles */
        .info-tooltip {
            position: absolute;
            background: #1f2937;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            white-space: nowrap;
            z-index: 10000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 300px;
            word-wrap: break-word;
            white-space: normal;
        }
        
        .info-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #1f2937 transparent transparent transparent;
        }
        
        /* Styles for search suggestions */
        #search-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #d1d5db;
            border-top: none;
            border-radius: 0 0 0.375rem 0.375rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 2100;
            max-height: 200px;
            overflow-y: auto;
        }
        
        #search-suggestions li {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid #e5e7eb;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        #search-suggestions li:last-child {
            border-bottom: none;
        }
        
        #search-suggestions li:hover, #search-suggestions li.highlighted {
            background-color: #eff6ff; /* bg-blue-50 */
        }
        
        /* Hide default clear button for search input */
        #search-input::-webkit-search-cancel-button {
            -webkit-appearance: none;
            appearance: none;
        }
        
        /* NEW: Tooltip for search results */
        .search-result-tooltip {
            position: absolute;
            background: #1f2937;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 10000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 250px;
            white-space: normal; /* Allow wrapping */
        }

        /* Context Menu Styles */
        #contextMenu {
            background: rgba(255, 255, 255, 0.8); /* Transparent white */
            backdrop-filter: blur(10px); /* Blur effect */
            -webkit-backdrop-filter: blur(10px); /* Safari support */
            border: 1px solid rgba(200, 200, 200, 0.4);
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 0.5rem;
            z-index: 5000; /* Ensure it's on top of other elements */
            min-width: 220px;
            transform-origin: top left; /* For potential future animations */
            transition: opacity 0.1s ease-out;
        }

        .elevation-highlight-marker {
            background: #F59E0B;
            border: 2px solid white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        /* MapLibre/MapTiler SDK compatibility styles */
        .maptiler-ctrl-group {
            background: rgba(255, 255, 255, 0.8) !important;
            backdrop-filter: blur(10px) !important;
            -webkit-backdrop-filter: blur(10px) !important;
            border: 1px solid rgba(200, 200, 200, 0.4) !important;
            border-radius: 0.5rem !important;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important;
        }
        .maptiler-ctrl button {
            background-color: transparent !important;
            width: 30px !important;
            height: 30px !important;
        }
        .maptiler-ctrl-top-left {
            left: 1rem;
            top: 90px; /* Position below address button */
        }



        /* --- FONT SCALING FOR LARGE DISPLAYS --- */
        @media (min-width: 1920px) {
            html {
                font-size: 17px; /* Base is 16px, this is ~6% larger */
            }
        }
        @media (min-width: 2560px) {
            html {
                font-size: 18px; /* This is ~12.5% larger */
            }
        }
        @media (min-width: 3840px) {
            html {
                font-size: 20px; /* This is 25% larger */
            }
        }

    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,300;0,400;0,500;0,600;0,700;1,400&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100">
    <!-- Main container for the map -->
    <div class="relative w-screen h-screen">
        <div id="map"></div>
        
        <!-- Top Left Address Panel -->
        <div class="absolute top-[210px] left-4 z-[1001]">
            <button id="addressToggle" class="action-button" title="Î•Î¼Ï†Î¬Î½Î¹ÏƒÎ· Î»Î¯ÏƒÏ„Î±Ï‚ Î´Î¹ÎµÏ…Î¸ÏÎ½ÏƒÎµÏ‰Î½">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path></svg>
            </button>
        </div>
        <div id="addressPanel" class="absolute top-[260px] left-4 z-[1000] menu-hidden glass-panel rounded-lg shadow-md p-4 w-[320px]">
            <div class="absolute top-2 right-2 flex gap-1 z-10"> <!-- New container for buttons -->
                <button id="addressPanelReload" class="p-1 rounded-full hover:bg-gray-400/30 transition-colors" title="Î‘Î½Î±Î½Î­Ï‰ÏƒÎ· Î»Î¯ÏƒÏ„Î±Ï‚">
                    <svg class="w-4 h-4 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004 12c0 2.972 1.154 5.661 3.042 7.707M20 20v-5h-.581m0 0a8.001 8.001 0 01-15.357-2A8.001 8.001 0 0120 12c0-2.972-1.154-5.661-3.042-7.707"></path></svg>
                </button>
                <button id="addressPanelClose" class="p-1 rounded-full hover:bg-gray-400/30 transition-colors" title="ÎšÎ»ÎµÎ¯ÏƒÎ¹Î¼Î¿ Î»Î¯ÏƒÏ„Î±Ï‚">
                    <svg class="w-5 h-5 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <h2 class="text-lg font-bold mb-2 text-gray-800">Î£Î·Î¼ÎµÎ¯Î± Î”Î¹Î±Î´ÏÎ¿Î¼Î®Ï‚</h2>
            <div id="addressList" class="overflow-y-auto pr-2">
                <p id="no-addresses-message" class="text-gray-500 text-sm">Î ÏÎ¿ÏƒÎ¸Î­ÏƒÏ„Îµ ÏƒÎ·Î¼ÎµÎ¯Î± ÏƒÏ„Î· Î´Î¹Î±Î´ÏÎ¿Î¼Î® Î³Î¹Î± Î½Î± Î´ÎµÎ¯Ï„Îµ Ï„Î¹Ï‚ Î´Î¹ÎµÏ…Î¸ÏÎ½ÏƒÎµÎ¹Ï‚.</p>
            </div>
        </div>
        
        <!-- Top Right Buttons -->
        <div id="topRightControls" class="absolute top-4 right-4 z-[2000]">
            <!-- Undo Button (Stretched) -->
            <button id="undoButton" class="action-button disabled:opacity-50 disabled:cursor-not-allowed absolute right-[3.5rem] w-[calc(300px-3.5rem+2px)] text-center" title="Î‘Î½Î±Î¯ÏÎµÏƒÎ·" disabled>
                <span class="text-xl leading-none">â†¶ Î‘Î½Î±Î¯ÏÎµÏƒÎ·</span>
            </button>
            <!-- Menu Toggle Button -->
            <button id="menuToggle" class="action-button float-right">
                <svg id="menuIcon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                </svg>
                <svg id="closeIcon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
            </button>
            <!-- Top Right Loading Spinner (for general operations) -->
            <div id="topRightLoader" class="absolute right-[19.375rem] top-[0.25rem] z-[2001] hidden">
                <div class="bg-white p-2 rounded-full shadow-lg">
                    <div class="loading-spinner"></div>
                </div>
            </div>
        </div>
        
        <!-- Floating Menu Panel -->
        <div id="menuPanel" class="menu-panel menu-hidden glass-panel rounded-lg shadow-md">
             <!-- Search Bar -->
            <div class="relative mb-4">
                <input type="search" id="search-input" placeholder="Î‘Î½Î±Î¶Î®Ï„Î·ÏƒÎ· Ï„Î¿Ï€Î¿Î¸ÎµÏƒÎ¯Î±Ï‚..." class="w-full pl-3 pr-10 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                <div id="search-icon-container" class="absolute inset-y-0 right-0 flex items-center pr-3 cursor-pointer">
                    <svg id="search-magnifying-glass" class="w-5 h-5 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd"></path>
                    </svg>
                    <div id="search-spinner" class="search-spinner hidden"></div>
                </div>
                 <ul id="search-suggestions" class="hidden"></ul>
            </div>

            <h1 class="text-xl font-bold mb-4 text-gray-800 flex items-center gap-2">
                <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
                </svg>
                Î£Ï‡ÎµÎ´Î¹Î±ÏƒÏ„Î®Ï‚ Î”Î¹Î±Î´ÏÎ¿Î¼Î®Ï‚
            </h1>
            <div class="flex flex-col gap-3">
                <button id="clearRoute" class="flex items-center justify-center gap-2 px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 transition-colors shadow-sm">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                    </svg>
                    ÎšÎ±Î¸Î±ÏÎ¹ÏƒÎ¼ÏŒÏ‚
                </button>
                <button id="downloadGPX" class="flex items-center justify-center gap-2 px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors shadow-sm" style="display: none;">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                    Î›Î®ÏˆÎ· GPX
                </button>
                <button id="uploadGPX" class="flex items-center justify-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors shadow-sm">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                    Î¦ÏŒÏÏ„Ï‰ÏƒÎ· GPX
                </button>
                <input type="file" id="gpx-file-input" class="hidden" accept=".gpx">
                <button id="downloadPDF" class="flex items-center justify-center gap-2 px-4 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 transition-colors shadow-sm" style="display: none;">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                    Î›Î®ÏˆÎ· pdf Î´Î¹Î±Î´ÏÎ¿Î¼Î®Ï‚
                </button>
            </div>
            
            <!-- Round Trip Toggle -->
            <div class="mt-4 pt-4 border-t border-gray-200">
                <label for="roundTripToggle" class="flex items-center justify-between cursor-pointer">  
                    <span class="font-medium text-gray-800">ÎšÏ…ÎºÎ»Î¹ÎºÎ® Î”Î¹Î±Î´ÏÎ¿Î¼Î®</span>
                    <div class="relative">
                        <input type="checkbox" id="roundTripToggle" class="sr-only peer">
                        <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-400 peer-checked:bg-blue-600"></div>
                        <div class="absolute left-1 top-1 bg-white border-gray-300 border rounded-full h-4 w-4 transition-transform peer-checked:translate-x-full"></div>
                    </div>
                </label>
            </div>

            <!-- Steep Uphill Toggle -->
            <div class="mt-4 pt-4 border-t border-gray-200">
                <label for="steepUphillToggle" class="flex items-center justify-between cursor-pointer">
                    <span class="font-medium text-gray-800">Î‘Ï€ÏŒÏ„Î¿Î¼Î· Î±Î½Î¬Î²Î±ÏƒÎ·</span>
                    <div class="relative">
                        <input type="checkbox" id="steepUphillToggle" class="sr-only peer">
                        <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-400 peer-checked:bg-blue-600"></div>
                        <div class="absolute left-1 top-1 bg-white border-gray-300 border rounded-full h-4 w-4 transition-transform peer-checked:translate-x-full"></div>
                    </div>
                </label>
            </div>

            <!-- Share Button -->
            <div class="mt-4 pt-4 border-t border-gray-200">
                <button id="shareButton" class="w-full flex items-center justify-center gap-2 px-4 py-2 bg-indigo-500 text-white rounded-md hover:bg-indigo-600 transition-colors shadow-sm disabled:bg-indigo-300 disabled:cursor-not-allowed" disabled>
                    <span class="text-xl">ğŸ“‹</span>
                    ÎšÎ¿Î¹Î½Î® Ï‡ÏÎ®ÏƒÎ·
                </button>           
            </div>

            <!-- Map Style Switcher -->
            <div class="mt-4 pt-4 border-t border-gray-200">
                <label for="mapStyleSwitcher" class="block font-medium text-gray-800 mb-2">Î£Ï„Ï…Î» Î§Î¬ÏÏ„Î·</label>
                <select id="mapStyleSwitcher" class="w-full p-2 border border-gray-300 rounded-md bg-white text-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>


        </div>

        <!-- Right-Click Context Menu -->
        <div id="contextMenu" class="absolute hidden">
            <button id="addWaypointBtn" class="w-full text-left px-3 py-2 text-sm font-semibold text-gray-800 hover:bg-blue-100 hover:text-blue-700 rounded-md flex items-center gap-3">
                <svg class="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 6V4m0 14v-2m-6-6H4m14 0h-2"></path></svg>
                Î ÏÎ¿ÏƒÎ¸Î®ÎºÎ· Î•Î½Î´Î¹Î¬Î¼ÎµÏƒÎ¿Ï… Pin
            </button>
            <button id="removePinBtn" class="w-full text-left px-3 py-2 text-sm font-semibold text-red-800 hover:bg-red-100 hover:text-red-700 rounded-md flex items-center gap-3">
                <svg class="w-5 h-5 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                Î‘Ï†Î±Î¯ÏÎµÏƒÎ· Pin
            </button>
            <!-- Î ÏÎ¿ÏƒÎ¸Î­ÏƒÏ„Îµ ÎµÎ´Ï ÎºÎ±Î¹ Î¬Î»Î»ÎµÏ‚ ÎµÏ€Î¹Î»Î¿Î³Î­Ï‚ Î¼ÎµÎ»Î»Î¿Î½Ï„Î¹ÎºÎ¬ -->
        </div>


        <!-- Top Right Loading Spinner (for general operations) -->
        <div id="topRightLoader" class="absolute top-20 right-6 z-[1999] hidden">
            <div class="bg-white p-2 rounded-full shadow-lg">
                <div class="loading-spinner"></div>
            </div>
        </div>

        <!-- Notification & Error Message Overlay -->
        <div id="messageOverlay" class="absolute top-24 left-1/2 transform -translate-x-1/2 px-4 py-3 rounded-md shadow-lg z-[4000]" style="display: none;">
            <span id="messageText"></span>
        </div>
        
        <!-- Instructions Overlay -->
        <div id="instructions" class="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-blue-50 border border-blue-200 px-4 py-2 rounded-lg shadow-lg z-[900]">
            <p class="text-blue-800 text-sm font-medium">
                ÎšÎ¬Î½Ï„Îµ ÎºÎ»Î¹Îº ÏƒÏ„Î¿Î½ Ï‡Î¬ÏÏ„Î· Î³Î¹Î± Î½Î± Ï€ÏÎ¿ÏƒÎ¸Î­ÏƒÎµÏ„Îµ ÏƒÎ·Î¼ÎµÎ¯Î±.
            </p>
        </div>

        <!-- Button to show the bottom panel -->
        <button id="show-panel-button" class="absolute bottom-4 right-4 p-3 bg-white rounded-full shadow-lg hover:bg-gray-100 transition hidden z-[1001]" title="Î•Î¼Ï†Î¬Î½Î¹ÏƒÎ· Ï€Î¯Î½Î±ÎºÎ±">
            <svg class="w-6 h-6 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path>
            </svg>
        </button>
    </div>

    <!-- Bottom Section: Stats & Elevation Profile -->
    <div id="bottomPanel" class="absolute bottom-0 left-0 right-0 flex flex-col lg:flex-row z-[1002] glass-panel">
        
        <!-- Button to hide the bottom panel -->
        <button id="hide-panel-button" class="absolute top-2 right-2 p-2 rounded-full hover:bg-gray-400/30 transition-colors z-10" title="Î‘Ï€ÏŒÎºÏÏ…ÏˆÎ· Ï€Î¯Î½Î±ÎºÎ±">
            <svg class="w-6 h-6 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
            </svg>
        </button>

        <!-- Left Area: Route Statistics Panel -->
        <div id="stats-panel" class="w-full lg:w-[30%] p-4 border-r border-gray-200/50 overflow-y-auto h-1/2 lg:h-full">
            <h2 class="text-lg font-bold mb-4 text-gray-800 text-center">Î£Ï„Î±Ï„Î¹ÏƒÏ„Î¹ÎºÎ¬ Î”Î¹Î±Î´ÏÎ¿Î¼Î®Ï‚</h2>
            <div id="stats-content" class="grid grid-cols-4 gap-3">
                <!-- Total Distance -->
                <div class="col-span-4 text-center p-3 rounded-lg shadow-md">
                    <div class="text-gray-700 text-xs uppercase tracking-wider font-semibold">Î£Ï…Î½Î¿Î»Î¹ÎºÎ® Î‘Ï€ÏŒÏƒÏ„Î±ÏƒÎ·</div>
                    <div id="totalDistance" class="font-bold text-3xl text-blue-600 mt-1">--</div>
                </div>
                
                <!-- Steep Uphill -->
                <div class="col-span-4 text-center p-2 rounded-lg shadow-md">
                    <div class="text-gray-700 text-xs uppercase tracking-wider font-semibold leading-tight">ÎœÎ®ÎºÎ¿Ï‚ Î‘Ï€ÏŒÏ„Î¿Î¼Î·Ï‚ Î‘Î½Î¬Î²Î±ÏƒÎ·Ï‚ (&gt;5%)</div>
                    <div id="steepUphillDistance" class="font-bold text-2xl text-red-600 mt-1">--</div>
                </div>
                <!-- Elevation Gain -->
                <div class="col-span-4 text-center p-2 rounded-lg shadow-md">
                    <div class="text-gray-700 text-xs uppercase tracking-wider font-semibold">Î˜ÎµÏ„Î¹ÎºÎ® Î¥ÏˆÎ¿Î¼ÎµÏ„ÏÎ¹ÎºÎ®</div>
                    <div id="elevationGain" class="font-bold text-2xl text-green-600 mt-1">--</div>
                </div>
            </div>
             <div id="no-stats-message" class="flex items-center justify-center h-full text-gray-500">
                Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÏ„Îµ Î¼Î¹Î± Î´Î¹Î±Î´ÏÎ¿Î¼Î® Î³Î¹Î± Î½Î± Î´ÎµÎ¯Ï„Îµ Ï„Î± ÏƒÏ„Î±Ï„Î¹ÏƒÏ„Î¹ÎºÎ¬.
            </div>
        </div>

        <!-- Right Area: Elevation Profile Graph -->
        <div id="elevation-panel" class="w-full lg:w-[70%] p-4 flex flex-col h-1/2 lg:h-full">
            <h2 class="text-lg font-bold mb-2 text-gray-800 text-center">Î¥ÏˆÎ¿Î¼ÎµÏ„ÏÎ¹ÎºÏŒ Î ÏÎ¿Ï†Î¯Î»</h2>
            <div id="elevationChartContainer" class="flex-grow relative -ml-4">
                <canvas id="elevationChart"></canvas>
                <div id="no-elevation-message" class="flex items-center justify-center h-full text-gray-500">
                    Î¤Î¿ Î³ÏÎ¬Ï†Î·Î¼Î± Î¸Î± ÎµÎ¼Ï†Î±Î½Î¹ÏƒÏ„ÎµÎ¯ ÎµÎ´Ï.
                </div>
            </div>
        </div>
    </div>

    <!-- MapTiler SDK JS -->
    <script src="https://cdn.maptiler.com/maptiler-sdk-js/v2.0.3/maptiler-sdk.umd.min.js"></script>

    <!-- PDF Generation Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html-to-image/1.11.11/html-to-image.min.js"></script>
    
    <script>
        // --- PDF GENERATION ---
        function generateSteepnessReport(routeCoordinates) {
            if (!routeCoordinates || routeCoordinates.length < 2) {
                return [];
            }

            let segments = [];
            let currentSegment = {
                gradients: [],
                distance: 0,
                startDistance: 0
            };
            let lastSteepStatus = null;
            let cumulativeDistance = 0;

            for (let i = 1; i < routeCoordinates.length; i++) {
                const p1 = routeCoordinates[i - 1];
                const p2 = routeCoordinates[i];
                const segmentDistance = calculateHaversineDistance(p1, p2);
                const elevationDiff = p2[2] - p1[2];
                let gradient = 0;
                if (segmentDistance > 0) {
                    gradient = elevationDiff / segmentDistance;
                }
                
                const isSteep = gradient > CONFIG.STEEP_GRADIENT_THRESHOLD;

                if (i === 1) {
                    lastSteepStatus = isSteep;
                }

                if (isSteep !== lastSteepStatus) {
                    if (currentSegment.distance > 0) {
                        currentSegment.endDistance = cumulativeDistance;
                        currentSegment.isSteep = lastSteepStatus; // Attach status
                        segments.push(currentSegment);
                    }
                    currentSegment = {
                        gradients: [],
                        distance: 0,
                        startDistance: cumulativeDistance
                    };
                }
                
                currentSegment.gradients.push(gradient);
                currentSegment.distance += segmentDistance;
                cumulativeDistance += segmentDistance;
                lastSteepStatus = isSteep;
            }
            
            if (currentSegment.distance > 0) {
                currentSegment.endDistance = cumulativeDistance;
                currentSegment.isSteep = lastSteepStatus; // Attach status for the last segment
                segments.push(currentSegment);
            }

            return segments.map(seg => {
                const avgGradient = seg.gradients.reduce((a, b) => a + b, 0) / (seg.gradients.length || 1);
                const startKm = (seg.startDistance / 1000);
                const endKm = (seg.endDistance / 1000);

                return {
                    startKm: startKm.toFixed(2),
                    endKm: endKm.toFixed(2),
                    gradient: avgGradient.toFixed(1),
                    isSteep: seg.isSteep, // Use the attached status
                    distance: seg.distance
                };
            }).filter(seg => seg !== null);
        }

        // Helper to generate the HTML for the main statistics part of the report.
        function getPdfStatsHtml() {
            const totalDistance = document.getElementById('totalDistance').textContent;
            const steepUphillDistance = document.getElementById('steepUphillDistance').textContent;
            const elevationGain = document.getElementById('elevationGain').textContent;

            return `
                <h1 style="font-size: 24px; font-weight: bold; border-bottom: 2px solid #333; padding-bottom: 10px; margin-bottom: 20px; text-align: center;">Î‘Î½Î±Ï†Î¿ÏÎ¬ Î”Î¹Î±Î´ÏÎ¿Î¼Î®Ï‚</h1>
                <h2 style="font-size: 20px; font-weight: bold; margin-bottom: 10px; text-align: center;">Î£Ï„Î±Ï„Î¹ÏƒÏ„Î¹ÎºÎ¬</h2>
                <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px; font-size: 16px;">
                    <tr style="border-bottom: 1px solid #ccc;"><td style="padding: 8px; font-weight: bold;">Î£Ï…Î½Î¿Î»Î¹ÎºÎ® Î‘Ï€ÏŒÏƒÏ„Î±ÏƒÎ·:</td><td style="padding: 8px;">${totalDistance}</td></tr>
                    <tr style="border-bottom: 1px solid #ccc;"><td style="padding: 8px; font-weight: bold;">ÎœÎ®ÎºÎ¿Ï‚ Î‘Ï€ÏŒÏ„Î¿Î¼Î·Ï‚ Î‘Î½Î¬Î²Î±ÏƒÎ·Ï‚ (>5%):</td><td style="padding: 8px;">${steepUphillDistance}</td></tr>
                    <tr style="border-bottom: 1px solid #ccc;"><td style="padding: 8px; font-weight: bold;">Î˜ÎµÏ„Î¹ÎºÎ® Î¥ÏˆÎ¿Î¼ÎµÏ„ÏÎ¹ÎºÎ®:</td><td style="padding: 8px;">${elevationGain}</td></tr>
                </table>
            `;
        }

        // Helper to generate the HTML for a chunk of the slope analysis table.
        function getPdfSlopeTableHtml(segments, totalSteepDistance, isFirstPage) {
            const formatDistance = (d) => d > 1000 ? `${(d / 1000).toFixed(2)} km` : `${Math.round(d)} m`;
            
            let tableRowsHtml = segments.map(seg => {
                const gradientStyle = seg.isSteep ? 'color: red;' : '';
                let steepLengthText = '-';
                if (seg.isSteep) {
                    steepLengthText = `<span style="color: red;">${formatDistance(seg.distance)}</span>`;
                }
                return `
                    <div style="display: table-row; border-bottom: 1px solid #ccc;">
                        <div style="display: table-cell; padding: 12px; text-align: center;">${seg.startKm} km</div>
                        <div style="display: table-cell; padding: 12px; text-align: center;">${seg.endKm} km</div>
                        <div style="display: table-cell; padding: 12px; text-align: center; ${gradientStyle}">${(seg.gradient * 100).toFixed(1)}%</div>
                        <div style="display: table-cell; padding: 12px; text-align: center;">${steepLengthText}</div>
                    </div>
                `;
            }).join('');

            const title = isFirstPage ? 'Î‘Î½Î¬Î»Ï…ÏƒÎ· ÎšÎ»Î¯ÏƒÎµÏ‰Î½' : 'Î‘Î½Î¬Î»Ï…ÏƒÎ· ÎšÎ»Î¯ÏƒÎµÏ‰Î½ (ÏƒÏ…Î½Î­Ï‡ÎµÎ¹Î±)';

            let fullTableHtml = `
                <h2 style="font-size: 20px; font-weight: bold; margin-top: 30px; margin-bottom: 10px; text-align: center;">${title}</h2>
                <div style="display: table; width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 14px;">
                    <div style="display: table-header-group; font-weight: bold; break-inside: avoid;">
                        <div style="display: table-row; border-bottom: 2px solid #555;">
                            <div style="display: table-cell; padding: 12px; text-align: center; width: 20%;">Î‘Ï€ÏŒ</div>
                            <div style="display: table-cell; padding: 12px; text-align: center; width: 20%;">ÎˆÏ‰Ï‚</div>
                            <div style="display: table-cell; padding: 12px; text-align: center; width: 20%;">ÎšÎ»Î¯ÏƒÎ·</div>
                            <div style="display: table-cell; padding: 12px; text-align: center; width: 40%;">ÎœÎ®ÎºÎ¿Ï‚ Î‘Ï€ÏŒÏ„Î¿Î¼Î·Ï‚ Î‘Î½Î¬Î²Î±ÏƒÎ·Ï‚</div>
                        </div>
                    </div>
                    <div style="display: table-row-group;">
                        ${tableRowsHtml}
                    </div>
                </div>
            `;

            // Add total steep distance only on the last page
            if (totalSteepDistance !== null) {
                fullTableHtml += `
                    <div style="display: table; width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 15px; break-inside: avoid;">
                        <div style="display: table-row;">
                            <div style="display: table-cell; padding: 12px; text-align: left; font-weight: bold; width: 60%;">Î£Ï…Î½Î¿Î»Î¹ÎºÏŒ ÎœÎ®ÎºÎ¿Ï‚ Î‘Ï€ÏŒÏ„Î¿Î¼Î·Ï‚ Î‘Î½Î¬Î²Î±ÏƒÎ·Ï‚ (>5%):</div>
                            <div style="display: table-cell; padding: 12px; text-align: center; font-weight: bold; color: red; width: 40%;">${formatDistance(totalSteepDistance)}</div>
                        </div>
                    </div>
                `;
            }
            
            return fullTableHtml;
        }

        // Helper to measure the pixel height of the table header and a sample row.
        async function measurePdfElements(reportElement, sampleSegment) {
            const canvasScale = 2;
            
            // 1. Measure Header
            const headerHtml = getPdfSlopeTableHtml([], null, true);
            reportElement.innerHTML = headerHtml;
            const headerCanvas = await html2canvas(reportElement, { scale: canvasScale });
            const headerHeight = headerCanvas.height;

            // 2. Measure Header + One Row
            const tableWithOneRowHtml = getPdfSlopeTableHtml([sampleSegment], null, true);
            reportElement.innerHTML = tableWithOneRowHtml;
            const combinedCanvas = await html2canvas(reportElement, { scale: canvasScale });
            const combinedHeight = combinedCanvas.height;

            // 3. Calculate Row Height
            const rowHeight = combinedHeight - headerHeight;

            return { headerHeight, rowHeight };
        }

        async function downloadRoutePDF() {
            if (!state.currentRoute) {
                showMessage('Î”ÎµÎ½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Î´Î¹Î±Î´ÏÎ¿Î¼Î® Î³Î¹Î± Î»Î®ÏˆÎ·', 'error');
                return;
            }
            if (typeof jspdf === 'undefined' || typeof html2canvas === 'undefined' || typeof htmlToImage === 'undefined') {
                showMessage('ÎŸÎ¹ Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎµÏ‚ PDF Î® ÎµÎ¹ÎºÏŒÎ½Î±Ï‚ Î´ÎµÎ½ Î­Ï‡Î¿Ï…Î½ Ï†Î¿ÏÏ„Ï‰Î¸ÎµÎ¯. Î”Î¿ÎºÎ¹Î¼Î¬ÏƒÏ„Îµ Î¾Î±Î½Î¬.', 'error');
                return;
            }

            showLoading(true);

            // --- Setup ---
            const { jsPDF } = jspdf;
            const pdf = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            const margin = 10;
            const contentWidthMM = pdfWidth - margin * 2;
            const contentHeightMM = pdfHeight - margin * 2;
            const canvasScale = 2;

            const reportElement = document.createElement('div');
            reportElement.id = 'pdf-report-generator';
            reportElement.style.position = 'absolute';
            reportElement.style.left = '-9999px';
            reportElement.style.width = '800px'; // Use a fixed, high-res width
            reportElement.style.padding = '20px';
            reportElement.style.fontFamily = 'Arial, sans-serif';
            reportElement.style.color = '#000';
            reportElement.style.backgroundColor = '#fff';
            document.body.appendChild(reportElement);

            const elementsToHide = [
                document.getElementById('menuPanel'),
                document.getElementById('topRightControls'),
                document.getElementById('addressToggle'),
                document.getElementById('addressPanel'),
                document.getElementById('instructions'),
                document.getElementById('messageOverlay'),
                document.getElementById('contextMenu'),
                document.getElementById('hide-panel-button'),
                document.getElementById('show-panel-button'),
                ...document.querySelectorAll('.maptiler-control-container, .maplibregl-control-container')
            ];
            const originalDisplays = new Map();
            const bottomPanel = document.getElementById('bottomPanel');

            try {
                // --- Page 1: Stats ---
                reportElement.innerHTML = getPdfStatsHtml();
                const statsCanvas = await html2canvas(reportElement, { scale: canvasScale });
                const statsImgData = statsCanvas.toDataURL('image/png');
                const statsImgHeight = statsCanvas.height * contentWidthMM / statsCanvas.width;
                pdf.addImage(statsImgData, 'PNG', margin, margin, contentWidthMM, statsImgHeight);

                // --- Pages 2...N: Slope Analysis Table ---
                const segments = generateSteepnessReport(state.currentRoute.coordinates);
                if (segments.length > 0) {
                    const totalSteepDistance = segments.reduce((total, seg) => total + (seg.isSteep ? seg.distance : 0), 0);

                    // 1. Measure
                    const { headerHeight, rowHeight } = await measurePdfElements(reportElement, segments[0]);
                    
                    // 2. Calculate rows per page
                    const pageCanvasHeight = reportElement.offsetWidth * canvasScale * (pdfHeight / pdfWidth);
                    const contentCanvasHeight = pageCanvasHeight - (margin * 2 * (pageCanvasHeight / pdfHeight));
                    
                    let rowsPerPage = Math.floor((contentCanvasHeight - headerHeight) / rowHeight);
                    if (rowsPerPage <= 0) rowsPerPage = 1;

                    // 3. Chunk segments
                    const chunks = [];
                    for (let i = 0; i < segments.length; i += rowsPerPage) {
                        chunks.push(segments.slice(i, i + rowsPerPage));
                    }

                    // 4. Render each chunk to a new page
                    for (let i = 0; i < chunks.length; i++) {
                        const chunk = chunks[i];
                        const isLastChunk = i === chunks.length - 1;
                        const tableHtml = getPdfSlopeTableHtml(chunk, isLastChunk ? totalSteepDistance : null, i === 0);
                        
                        reportElement.innerHTML = tableHtml;
                        const tableCanvas = await html2canvas(reportElement, { scale: canvasScale });
                        const tableImgData = tableCanvas.toDataURL('image/png');
                        const tableImgHeight = tableCanvas.height * contentWidthMM / tableCanvas.width;
                        
                        pdf.addPage();
                        pdf.addImage(tableImgData, 'PNG', margin, margin, contentWidthMM, tableImgHeight);
                    }
                }

                // --- Final Page: Map Screenshot ---
                elementsToHide.forEach(el => {
                    if (el) {
                        originalDisplays.set(el, el.style.display);
                        el.style.display = 'none';
                    }
                });
                
                if (bottomPanel) {
                    bottomPanel.style.background = 'rgba(255, 255, 255, 0.9)';
                    bottomPanel.style.backdropFilter = 'none';
                    bottomPanel.style.webkitBackdropFilter = 'none';
                }

                // Wait for map to be fully rendered before taking screenshot
                state.map.triggerRepaint();
                await new Promise(resolve => {
                    state.map.once('idle', () => {
                        // A short timeout after idle seems to help html-to-image capture the final state
                        setTimeout(resolve, 100);
                    });
                });

                const mapImageData = await htmlToImage.toPng(document.body, {
                    quality: 0.95,
                    pixelRatio: 1.5,
                    filter: (node) => node.id !== 'pdf-report-generator'
                });

                const image = new Image();
                image.src = mapImageData;
                await new Promise(resolve => { image.onload = resolve; });

                pdf.addPage('a4', 'landscape');
                const pageW = pdf.internal.pageSize.getWidth();
                const pageH = pdf.internal.pageSize.getHeight();
                const pageAspectRatio = pageW / pageH;
                const imageAspectRatio = image.width / image.height;

                let finalImgW, finalImgH, posX, posY;
                if (imageAspectRatio > pageAspectRatio) {
                    finalImgW = pageW;
                    finalImgH = pageW / imageAspectRatio;
                    posX = 0;
                    posY = (pageH - finalImgH) / 2;
                } else {
                    finalImgH = pageH;
                    finalImgW = pageH * imageAspectRatio;
                    posX = (pageW - finalImgW) / 2;
                    posY = 0;
                }

                pdf.addImage(mapImageData, 'PNG', posX, posY, finalImgW, finalImgH);

                pdf.save('route-report.pdf');

            } catch (error) {
                console.error("PDF generation failed:", error);
                showMessage('Î— Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± Ï„Î¿Ï… PDF Î±Ï€Î­Ï„Ï…Ï‡Îµ.', 'error');
            } finally {
                document.body.removeChild(reportElement);
                originalDisplays.forEach((display, el) => {
                    if(el) el.style.display = display;
                });
                
                if (bottomPanel) {
                    bottomPanel.style.background = '';
                    bottomPanel.style.backdropFilter = '';
                    bottomPanel.style.webkitBackdropFilter = '';
                }

                showLoading(false);
            }
        }


        // --- CONFIGURATION ---
        // --- CONFIGURATION ---
        const CONFIG = {
            OPENROUTE_API_KEY: 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjA4MzcyNTdiZjZkYjQxODc4YWY3Y2I4ZDA1OTVjMTI3IiwiaCI6Im11cm11cjY0In0=',
            GRAPHHOPPER_KEY: 'add98983-a73f-4f48-b753-d275ad3a3655',
            MAPTILER_API_KEY: 'u8zRQYN6M4dzdhc7tvka',
            ELEVATION_API_URL: 'https://api.open-elevation.com/api/v1/lookup',            
            MAX_PINS: 40, // Number of Pins
            DEFAULT_CENTER: [39.663967, 20.852770], // Ioannina, Greece
            DEFAULT_ZOOM: 13,
            STEEP_GRADIENT_THRESHOLD: 0.05, // percentage
            HISTORY_LIMIT: 40, // Max undo actions 
        };
        
        // --- GLOBAL STATE ---
        const state = {
            map: null,
            pins: [], // Stores maptilersdk.LngLat objects
            markers: [], // Stores maptilersdk.Marker objects
            // routePolylines, routeArrows, polylineDecorator are removed as they are Leaflet-specific
            elevationChart: null,
            currentRoute: null,
            // currentTileLayer is removed, managed by map.getStyle()
            mapStyles: {}, // To store MapTiler styles
            currentElevation: { data: [], coordinates: [] },
            highlightMarker: null,
            selectedMarkerIndex: -1,
            searchResultMarker: null,
            isRoundTrip: false,
            isChartJsLoaded: false,
            history: [],
            historyIndex: -1,
            showSteepHighlight: false,
            // Search state
            searchSuggestions: [],
            highlightedSuggestionIndex: -1,
            isSearchLoading: false,
            // Address Panel state
            // Address Panel state
            pinAddresses: [], // Will be an array of {status, address, lngLat} objects
            isAddressPanelVisible: false,
        };

        // --- ADDRESS PANEL LOGIC ---

        /**
         * Renders the list of addresses in the address panel based on the current state.
         */
        function renderAddressList() {
            const listEl = document.getElementById('addressList');

            if (!state.isAddressPanelVisible) {
                return;
            }

            if (state.pinAddresses.length === 0) {
                listEl.innerHTML = '<p id="no-addresses-message" class="text-gray-500 text-sm">Î ÏÎ¿ÏƒÎ¸Î­ÏƒÏ„Îµ ÏƒÎ·Î¼ÎµÎ¯Î± ÏƒÏ„Î· Î´Î¹Î±Î´ÏÎ¿Î¼Î® Î³Î¹Î± Î½Î± Î´ÎµÎ¯Ï„Îµ Ï„Î¹Ï‚ Î´Î¹ÎµÏ…Î¸ÏÎ½ÏƒÎµÎ¹Ï‚.</p>';
                return;
            }

            listEl.innerHTML = state.pinAddresses.map((item, index) => {
                let addressText = '';
                let isError = false;
                let isLoading = false;

                switch (item.status) {
                    case 'loading':
                        addressText = 'Î‘Î½Î±Î¶Î®Ï„Î·ÏƒÎ·...';
                        isLoading = true;
                        break;
                    case 'success':
                        addressText = item.address;
                        break;
                    case 'error':
                        addressText = 'Î‘Ï€Î¿Ï„Ï…Ï‡Î¯Î± Î»Î®ÏˆÎ·Ï‚';
                        isError = true;
                        break;
                    default: // 'empty'
                        addressText = '...';
                        break;
                }

                const isStart = index === 0;
                let pinClass = 'pin-icon';
                let pinContent = index + 1;
                if (isStart) {
                    pinClass += ' start';
                    if (state.isRoundTrip && state.pins.length > 1) {
                        pinClass += ' flag';
                        pinContent = 'ğŸ';
                    }
                }

                let actionButton = '';
                if (isLoading) {
                    actionButton = '<div class="search-spinner" style="width: 16px; height: 16px;"></div>';
                } else if (isError) {
                    actionButton = `<button class="p-1 rounded-full hover:bg-gray-400/30 retry-address-btn" data-index="${index}" title="Î•Ï€Î±Î½Î¬Î»Î·ÏˆÎ·">
                        <svg class="w-4 h-4 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004 12c0 2.972 1.154 5.661 3.042 7.707M20 20v-5h-.581m0 0a8.001 8.001 0 01-15.357-2A8.001 8.001 0 0120 12c0-2.972-1.154-5.661-3.042-7.707"></path></svg>
                    </button>`;
                }

                return `
                <div class="address-item flex items-center justify-between gap-3 p-2 rounded-md hover:bg-black/10" data-index="${index}">
                    <div class="flex items-center gap-3 cursor-pointer min-w-0">
                        <div class="flex-shrink-0">
                            <div class="${pinClass}" style="width: 28px; height: 28px; font-size: 13px; line-height: 28px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);">${pinContent}</div>
                        </div>
                        <div class="text-sm font-medium truncate ${isError ? 'text-red-600' : 'text-gray-800'}" title="${addressText}">${addressText}</div>
                    </div>
                    <div class="flex-shrink-0">${actionButton}</div>
                </div>
                `;
            }).join('');

            // Add event listeners for the "retry" buttons
            listEl.querySelectorAll('.retry-address-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const indexToRetry = parseInt(e.target.dataset.index, 10);
                    if (!isNaN(indexToRetry)) {
                        fetchAddressForPin(indexToRetry, true); // force retry
                    }
                });
            });

            // Add event listeners for panning to pin
            listEl.querySelectorAll('.address-item').forEach(itemEl => {
                itemEl.addEventListener('click', (e) => {
                    // Prevent clicking the retry button from also panning
                    if (e.target.closest('.retry-address-btn')) {
                        return;
                    }
                    const indexToPan = parseInt(itemEl.dataset.index, 10);
                    if (!isNaN(indexToPan)) {
                        panToPin(indexToPan);
                    }
                });
            });
        }


        /**
         * Fetches a human-readable address from geographic coordinates using MapTiler API.
         * @param {maptilersdk.LngLat} lngLat The coordinates to reverse geocode.
         * @returns {Promise<string>} A promise that resolves to the address string.
         */
        async function getAddressFromCoordinates(lngLat) {
            const url = `https://api.maptiler.com/geocoding/${lngLat.lng},${lngLat.lat}.json?key=${CONFIG.MAPTILER_API_KEY}&language=el`;
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error('Network response was not ok.');
            }
            const data = await response.json();
            if (data.features && data.features.length > 0) {
                return data.features[0].place_name;
            } else {
                throw new Error('No address found for these coordinates.');
            }
        }

        /**
         * Fetches and updates the address for a specific pin.
         * @param {number} index The index of the pin in the state.pins array.
         * @param {boolean} [force=false] If true, refetches the address even if it already exists.
         */
        async function fetchAddressForPin(index, force = false) {
            if (index < 0 || index >= state.pinAddresses.length) return;

            const item = state.pinAddresses[index];
            if (!item) return;

            // Don't refetch if already successful, unless forced
            if (item.status === 'success' && !force) return;
            // Don't start a new fetch if one is already in progress
            if (item.status === 'loading') return;

            item.status = 'loading';
            renderAddressList();

            try {
                const address = await getAddressFromCoordinates(item.lngLat);
                if (typeof address === 'string' || address instanceof String) {
                    item.address = address;
                    item.status = 'success';
                } else {
                    throw new Error("Invalid address format received.");
                }
            } catch (error) {
                console.error(`Failed to fetch address for pin ${index}:`, error);
                item.address = error.message; // Store error message
                item.status = 'error';
            }
            
            renderAddressList();
        }

        /**
         * Retries fetching addresses for all pins that previously failed.
         */
        function retryFailedAddresses() {
            state.pinAddresses.forEach((item, index) => {
                if (item.status === 'error') {
                    fetchAddressForPin(index, true); // Force retry
                }
            });
        }

        function panToPin(index) {
            if (state.pins[index]) {
                state.map.flyTo({ center: state.pins[index], zoom: 16 });
                
                // Remove highlight from previously selected marker
                if (state.selectedMarkerIndex !== -1 && state.markers[state.selectedMarkerIndex]) {
                    state.markers[state.selectedMarkerIndex].getElement().classList.remove('selected');
                }
                
                state.selectedMarkerIndex = index;
                
                // Add highlight to the new selected marker
                if (state.markers[index]) {
                    state.markers[index].getElement().classList.add('selected');
                }
            }
        }
                // --- DUPLICATED BLOCK REMOVED ---

        let rightClickLatLng = null; // Stores the LngLat of the right-click event
        let insertIndex = -1; // Stores the calculated index for waypoint insertion
        let rightClickedPinIndex = -1; // Stores the index of the right-clicked marker
        // --- UI ELEMENTS & SHARED VARIABLES ---
        let bottomPanel, hidePanelButton, showPanelButton;
        let activeSearchTooltip = null; // NEW: Variable to hold the active search result tooltip

        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', initApp);

        function initApp() {
            initMap();
            initUIElements();
            setupEventListeners();
            
            if (!parseUrlAndRestore()) {
                // saveState(); // TODO: Re-enable after refactoring saveState
            }
            
            updateStatsVisibility(false);
            console.log('Î•Ï†Î±ÏÎ¼Î¿Î³Î® Î£Ï‡ÎµÎ´Î¹Î±ÏƒÎ¼Î¿Ï Î”Î¹Î±Î´ÏÎ¿Î¼Î®Ï‚ Î±ÏÏ‡Î¹ÎºÎ¿Ï€Î¿Î¹Î®Î¸Î·ÎºÎµ Î¼Îµ MapTiler SDK.');
        }

        function initUIElements() {
            bottomPanel = document.getElementById('bottomPanel');
            hidePanelButton = document.getElementById('hide-panel-button');
            showPanelButton = document.getElementById('show-panel-button');
        }
        
        function initMap() {
            maptilersdk.config.apiKey = CONFIG.MAPTILER_API_KEY;

            state.map = new maptilersdk.Map({
                container: 'map',
                style: maptilersdk.MapStyle.STREETS,
                center: [CONFIG.DEFAULT_CENTER[1], CONFIG.DEFAULT_CENTER[0]],
                zoom: CONFIG.DEFAULT_ZOOM,
                hash: false,
                preserveDrawingBuffer: true
            });

            state.mapStyles = {
                'ÎŸÎ´Î¹ÎºÏŒÏ‚': maptilersdk.MapStyle.STREETS,
                'Î”Î¿ÏÏ…Ï†Î¿ÏÎ¹ÎºÏŒÏ‚': maptilersdk.MapStyle.SATELLITE,
                'Î¥Î²ÏÎ¹Î´Î¹ÎºÏŒÏ‚': maptilersdk.MapStyle.HYBRID,
                'Î¤Î¿Ï€Î¿Î³ÏÎ±Ï†Î¹ÎºÏŒÏ‚': maptilersdk.MapStyle.TOPO,
                'Î‘Ï€Î»ÏŒÏ‚': maptilersdk.MapStyle.BASIC,
            };

            state.map.on('load', () => {
                // Add standard controls to the top-left corner.
                state.map.addControl(new maptilersdk.NavigationControl(), 'top-left');
                state.map.addControl(new maptilersdk.TerrainControl({
                    source: 'terrainSource', // Source is added in reapplyCustomMapElements
                    exaggeration: 1.5
                }), 'top-left');

                // Initialize all our custom data sources and layers
                reapplyCustomMapElements();

                // Merge top-left and top-right controls into one block
                const controlContainer = state.map.getContainer().querySelector('.maplibregl-control-container, .maptiler-control-container');
                if (controlContainer) {
                    const topLeft = controlContainer.querySelector('.maplibregl-ctrl-top-left, .maptiler-ctrl-top-left');
                    const topRight = controlContainer.querySelector('.maplibregl-ctrl-top-right, .maptiler-ctrl-top-right');

                    if (topLeft && topRight) {
                        // Move all children from top-right to top-left
                        while (topRight.firstChild) {
                            topLeft.appendChild(topRight.firstChild);
                        }
                        topRight.style.display = 'none'; // Hide the empty container
                    }
                }
            });
            
            state.map.on('click', handleMapClick);
            state.map.on('contextmenu', handleMapRightClick);
            
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const { latitude, longitude } = position.coords;
                        state.map.flyTo({ center: [longitude, latitude], zoom: CONFIG.DEFAULT_ZOOM });
                    },
                    (error) => console.log('Î— Î³ÎµÏ‰ÎµÎ½Ï„Î¿Ï€Î¿Ï€Î¹ÏƒÎ· Î±Ï€Î­Ï„Ï…Ï‡Îµ:', error.message),
                    { timeout: 5000 }
                );
            }
        }
        
        function reapplyCustomMapElements() {
            // This function adds back all sources and layers that are not part of the map style
            // and are therefore removed whenever setStyle is called.

            // Guard against running multiple times
            if (state.map.getSource('routeSource')) return;

            // Add terrain source
            state.map.addSource('terrainSource', {
                type: 'raster-dem',
                url: `https://api.maptiler.com/tiles/terrain-rgb/tiles.json?key=${CONFIG.MAPTILER_API_KEY}`
            });

            // Add route data sources
            state.map.addSource('routeSource', { type: 'geojson', data: { type: 'Feature', geometry: null } });
            state.map.addSource('steepRouteSource', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
            state.map.addSource('routeArrowsSource', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });

            // Add layers
            state.map.addLayer({
                id: 'routeLayer',
                type: 'line',
                source: 'routeSource',
                layout: { 'line-join': 'round', 'line-cap': 'round' },
                paint: { 'line-color': '#3B82F6', 'line-width': 5, 'line-opacity': 0.8 }
            });
            state.map.addLayer({
                id: 'steepRouteLayer',
                type: 'line',
                source: 'steepRouteSource',
                layout: { 'line-join': 'round', 'line-cap': 'round' },
                paint: { 'line-color': '#EF4444', 'line-width': 6, 'line-opacity': 0 }
            });

            // Load arrow image and add layer
            const arrowSvg = `<svg width="20" height="20" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 0L11.1547 1.58254L17.863 5.99999H0V7.99999H17.863L11.1547 12.4175L12 14L24 7L12 0Z" fill="#333333"/></svg>`;
            const arrowUrl = `data:image/svg+xml;base64,${btoa(arrowSvg)}`;
            state.map.loadImage(arrowUrl, (error, image) => {
                if (error) { console.error('Failed to load arrow image:', error); return; }
                if (!state.map.hasImage('route-arrow')) {
                    state.map.addImage('route-arrow', image);
                }
                if (!state.map.getLayer('routeArrowsLayer')) {
                    state.map.addLayer({
                        id: 'routeArrowsLayer',
                        type: 'symbol',
                        source: 'routeArrowsSource',
                        layout: {
                            'icon-image': 'route-arrow',
                            'icon-size': 0.5,
                            'icon-rotate': ['get', 'bearing'],
                            'icon-rotation-alignment': 'map',
                            'icon-allow-overlap': true,
                            'icon-ignore-placement': true
                        }
                    });
                }
            });
        }

        function setupEventListeners() {
            document.getElementById('clearRoute').addEventListener('click', () => {
            state.pins = [];
            state.pinAddresses = [];
            renderAddressList();
            clearRoute(true)
        });
            document.getElementById('downloadGPX').addEventListener('click', downloadGPX);
            document.getElementById('uploadGPX').addEventListener('click', () => document.getElementById('gpx-file-input').click());
            document.getElementById('gpx-file-input').addEventListener('change', handleGpxFileUpload);
            document.getElementById('downloadPDF').addEventListener('click', downloadRoutePDF);
            document.getElementById('undoButton').addEventListener('click', undo);
            document.getElementById('shareButton').addEventListener('click', copyShareLink);

            // --- SEARCH FUNCTIONALITY ---
            const searchInput = document.getElementById('search-input');
            const suggestionsList = document.getElementById('search-suggestions');
            const debouncedSearch = debounce(fetchSearchSuggestions, 300);

            searchInput.addEventListener('input', () => {
                if (searchInput.value.trim().length >= 3) {
                    setSearchLoading(true);
                    debouncedSearch(searchInput.value);
                } else {
                    clearSuggestions();
                }
            });

            searchInput.addEventListener('keydown', handleSearchKeyDown);
            
            searchInput.addEventListener('blur', () => {
                setTimeout(() => {
                    if (!suggestionsList.contains(document.activeElement)) {
                        clearSuggestions();
                    }
                }, 150);
            });

            searchInput.addEventListener('search', () => {
                if (!searchInput.value) {
                    clearSuggestions();
                }
            });
            
            document.getElementById('search-icon-container').addEventListener('click', () => {
                if (searchInput.value) {
                    searchInput.value = '';
                    clearSuggestions();
                    searchInput.focus();
                }
            });

            // Menu toggle functionality
            const menuToggle = document.getElementById('menuToggle');
            const menuPanel = document.getElementById('menuPanel');
            const menuIcon = document.getElementById('menuIcon');
            const closeIcon = document.getElementById('closeIcon');
            
            menuToggle.addEventListener('click', () => {
                const isHidden = menuPanel.classList.contains('menu-hidden');
                if (isHidden) {
                    menuPanel.classList.remove('menu-hidden');
                    menuIcon.classList.add('hidden');
                    closeIcon.classList.remove('hidden');
                } else {
                    menuPanel.classList.add('menu-hidden');
                    menuIcon.classList.remove('hidden');
                    closeIcon.classList.add('hidden');
                }
            });

            // Panel visibility buttons
            hidePanelButton.addEventListener('click', hideBottomPanel);
            showPanelButton.addEventListener('click', showBottomPanel);

            // Toggles listeners
            document.getElementById('roundTripToggle').addEventListener('change', handleRoundTripToggle);
            document.getElementById('steepUphillToggle').addEventListener('change', handleSteepUphillToggle);

            window.addEventListener('resize', () => {
                if (state.map) {
                    setTimeout(() => state.map.resize(), 100);
                }
                if (state.elevationChart) {
                    setTimeout(() => {
                        state.elevationChart.resize();
                    }, 150);
                }
            });

            setupTooltips();

            // Event listener for the "Add Waypoint" button
            document.getElementById('addWaypointBtn').addEventListener('click', () => {
                if (rightClickLatLng && insertIndex !== -1) {
                    addWaypoint(rightClickLatLng, insertIndex);
                    document.getElementById('contextMenu').classList.add('hidden');
                }
            });

            // Event listener for the "Remove Pin" button
            document.getElementById('removePinBtn').addEventListener('click', () => {
                if (rightClickedPinIndex !== -1) {
                    removePin(rightClickedPinIndex);
                    document.getElementById('contextMenu').classList.add('hidden');
                }
            });

            // Address Panel listeners
            const addressToggle = document.getElementById('addressToggle');
            const addressPanel = document.getElementById('addressPanel');
            const addressPanelClose = document.getElementById('addressPanelClose');

            addressToggle.addEventListener('click', () => {
                state.isAddressPanelVisible = !state.isAddressPanelVisible;
                addressPanel.classList.toggle('menu-hidden', !state.isAddressPanelVisible);
                if (state.isAddressPanelVisible) {
                    renderAddressList(); // Render the current state when opening
                }
            });

            addressPanelClose.addEventListener('click', () => {
                state.isAddressPanelVisible = false;
                addressPanel.classList.add('menu-hidden');
            });

            document.getElementById('addressPanelReload').addEventListener('click', () => {
                retryFailedAddresses(); // Retry only failed addresses
            });

            // This function sets up all our custom sources and layers.
            // It's called on initial map load and after every style change.
            function reapplyCustomMapElements() {
                // Guard against running if sources already exist
                if (state.map.getSource('routeSource')) return;

                // Add sources
                state.map.addSource('terrainSource', {
                    type: 'raster-dem',
                    url: `https://api.maptiler.com/tiles/terrain-rgb/tiles.json?key=${CONFIG.MAPTILER_API_KEY}`
                });
                state.map.addSource('routeSource', { type: 'geojson', data: { type: 'Feature', geometry: null } });
                state.map.addSource('steepRouteSource', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
                state.map.addSource('routeArrowsSource', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });

                // Add layers
                state.map.addLayer({
                    id: 'routeLayer',
                    type: 'line',
                    source: 'routeSource',
                    layout: { 'line-join': 'round', 'line-cap': 'round' },
                    paint: { 'line-color': '#3B82F6', 'line-width': 5, 'line-opacity': 0.8 }
                });
                state.map.addLayer({
                    id: 'steepRouteLayer',
                    type: 'line',
                    source: 'steepRouteSource',
                    layout: { 'line-join': 'round', 'line-cap': 'round' },
                    paint: { 'line-color': '#EF4444', 'line-width': 6, 'line-opacity': 0 }
                });

                // Load arrow image and add layer
                const arrowSvg = `<svg width="20" height="20" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 0L11.1547 1.58254L17.863 5.99999H0V7.99999H17.863L11.1547 12.4175L12 14L24 7L12 0Z" fill="#333333"/></svg>`;
                const arrowUrl = `data:image/svg+xml;base64,${btoa(arrowSvg)}`;
                state.map.loadImage(arrowUrl, (error, image) => {
                    if (error) { console.error('Failed to load arrow image:', error); return; }
                    if (!state.map.hasImage('route-arrow')) {
                        state.map.addImage('route-arrow', image);
                    }
                    if (!state.map.getLayer('routeArrowsLayer')) {
                        state.map.addLayer({
                            id: 'routeArrowsLayer',
                            type: 'symbol',
                            source: 'routeArrowsSource',
                            layout: {
                                'icon-image': 'route-arrow',
                                'icon-size': 0.5,
                                'icon-rotate': ['get', 'bearing'],
                                'icon-rotation-alignment': 'map',
                                'icon-allow-overlap': true,
                                'icon-ignore-placement': true
                            }
                        });
                    }
                });

                // If a route already exists in the state, redraw it on the new style
                if (state.currentRoute) {
                    displayColoredRoute(state.currentRoute.coordinates);
                }
            }


            // --- MAP STYLE SWITCHER LOGIC ---
            const switcher = document.getElementById('mapStyleSwitcher');
            Object.keys(state.mapStyles).forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                switcher.appendChild(option);
            });

            switcher.addEventListener('change', (e) => {
                const selectedStyleName = e.target.value;
                const newStyle = state.mapStyles[selectedStyleName];

                if (newStyle) {
                    state.map.setStyle(newStyle);
                    
                    // After the style changes, re-apply our custom sources/layers.
                    // Then, if a route exists, wait for the map to be fully idle
                    // before attempting to redraw the route data. This prevents race conditions.
                    state.map.once('styledata', () => {
                        reapplyCustomMapElements();
                        if (state.currentRoute) {
                            state.map.once('idle', () => {
                                // A final check in case the user cleared the route while the style was changing
                                if (state.currentRoute) {
                                    displayColoredRoute(state.currentRoute.coordinates);
                                }
                            });
                
                            document.getElementById('elevationChart').addEventListener('mouseleave', () => {
                                if (state.highlightMarker) {
                                    state.highlightMarker.remove();
                                    state.highlightMarker = null;
                                }
                            });
                        }
                    });
                }
            });
        }

        // --- GENERIC TOOLTIP CREATION ---
        function setupTooltips() {
            createTooltipFor(
                document.querySelector('#roundTripToggle').closest('label'),
                'Î‘Î½Î¿Î¯Î³Î¿Î½Ï„Î¬Ï‚ Ï„Î¿, Î· Î´Î¹Î±Î´ÏÎ¿Î¼Î® ÏƒÎ±Ï‚ Î³Ï…ÏÎ¯Î¶ÎµÎ¹ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î± Ï€Î¯ÏƒÏ‰ ÏƒÏ„Î¿ ÏƒÎ·Î¼ÎµÎ¯Î¿ ÎµÎºÎºÎ¯Î½Î·ÏƒÎ·Ï‚.'
            );

            createTooltipFor(
                document.querySelector('#steepUphillToggle').closest('label'),
                'Î”ÎµÎ¯Ï‡Î½ÎµÎ¹ Î¼Îµ ÎºÏŒÎºÎºÎ¹Î½Î¿ Ï‡ÏÏÎ¼Î± Ï„Î¹Ï‚ Î±Ï€ÏŒÏ„Î¿Î¼ÎµÏ‚ Î±Î½Î·Ï†ÏŒÏÎµÏ‚ (>5%) ÏƒÏ„Î¿Î½ Ï‡Î¬ÏÏ„Î·.'
            );
        }

        function createTooltipFor(element, htmlContent) {
            let tooltip = null;

            const showTooltip = () => {
                if (tooltip) return;

                tooltip = document.createElement('div');
                tooltip.className = 'info-tooltip';
                tooltip.innerHTML = htmlContent;
                document.body.appendChild(tooltip);
                
                positionTooltip();
                
                setTimeout(() => {
                    if (tooltip) tooltip.style.opacity = '1';
                }, 10);
            };

            const hideTooltip = () => {
                if (tooltip) {
                    tooltip.style.opacity = '0';
                    setTimeout(() => {
                        if (tooltip && tooltip.parentNode) {
                            tooltip.parentNode.removeChild(tooltip);
                        }
                        tooltip = null;
                    }, 200);
                }
            };
            
            const positionTooltip = () => {
                if (!tooltip) return;
                const rect = element.getBoundingClientRect();
                tooltip.style.left = `${rect.left + window.scrollX + (rect.width / 2) - (tooltip.offsetWidth / 2)}px`;
                tooltip.style.top = `${rect.top + window.scrollY - tooltip.offsetHeight - 10}px`;
            };

            element.addEventListener('mouseenter', showTooltip);
            element.addEventListener('mouseleave', hideTooltip);
            window.addEventListener('resize', positionTooltip);
            window.addEventListener('scroll', positionTooltip, true);
        }
        
        // --- UNDO/HISTORY MANAGEMENT ---
        function saveState() {
            if (state.historyIndex < state.history.length - 1) {
                state.history = state.history.slice(0, state.historyIndex + 1);
            }

            const snapshot = {
                pins: state.pins.map(p => ({ lat: p.lat, lng: p.lng })),
                isRoundTrip: state.isRoundTrip,
                showSteepHighlight: state.showSteepHighlight
            };
            state.history.push(snapshot);
            state.historyIndex++;

            if (state.history.length > CONFIG.HISTORY_LIMIT + 1) {
                state.history.shift();
                state.historyIndex--;
            }
            
            updateUndoButton();
        }

        function undo() {
            if (state.historyIndex <= 0) return;
            state.historyIndex--;
            const previousState = state.history[state.historyIndex];
            restoreState(previousState);
        }
        
        function restoreState(snapshot) {
            // MapTiler uses LngLat object, which is compatible with {lng, lat}
            state.pins = snapshot.pins.map(p => new maptilersdk.LngLat(p.lng, p.lat));
            state.pinAddresses = state.pins.map(p => ({ status: 'empty', address: null, lngLat: p }));
            state.pinAddresses.forEach((_, index) => fetchAddressForPin(index));

            state.isRoundTrip = snapshot.isRoundTrip;
            state.showSteepHighlight = snapshot.showSteepHighlight ?? false;
            
            document.getElementById('roundTripToggle').checked = state.isRoundTrip;
            document.getElementById('steepUphillToggle').checked = state.showSteepHighlight;
            
            redrawFromState();
            updateUndoButton();
        }

        function redrawFromState() {
            // Remove existing markers from the map
            state.markers.forEach(marker => marker.remove());
            state.markers = [];
            
            // Clear route data from sources
            if (state.map.isStyleLoaded()) {
                const routeSource = state.map.getSource('routeSource');
                if (routeSource) routeSource.setData({ type: 'Feature', geometry: null });
                
                const steepSource = state.map.getSource('steepRouteSource');
                if (steepSource) steepSource.setData({ type: 'FeatureCollection', features: [] });
            }
            
            // Re-add markers based on the new state
            state.pins.forEach((pin, index) => {
                addMarker(pin, index + 1);
            });
            
            if (state.pins.length >= 2) {
                calculateRoute();
            } else {
                clearRoute(false); // This will also need refactoring
            }
            updateUIState();
        }
        
        // --- SHARE & URL FUNCTIONALITY ---
        function generateShareLink() {
            if (state.pins.length === 0) return null;

            const pinString = state.pins.map(p => `${p.lat.toFixed(5)},${p.lng.toFixed(5)}`).join('|');
            const dataString = `v1|${pinString}|${state.isRoundTrip}|${state.showSteepHighlight}`;
            const compressed = LZString.compressToEncodedURIComponent(dataString);

            const baseUrl = window.location.href.split('#')[0];
            return `${baseUrl}#${compressed}`;
        }

        function copyShareLink() {
            const link = generateShareLink();
            if (!link) {
                showMessage("Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÏ„Îµ Î¼Î¹Î± Î´Î¹Î±Î´ÏÎ¿Î¼Î® Ï€ÏÏÏ„Î±.", 'error');
                return;
            }

            navigator.clipboard.writeText(link).then(() => {
                showMessage('ÎŸ ÏƒÏÎ½Î´ÎµÏƒÎ¼Î¿Ï‚ Î±Î½Ï„Î¹Î³ÏÎ¬Ï†Î·ÎºÎµ ÏƒÏ„Î¿ Ï€ÏÏŒÏ‡ÎµÎ¹ÏÎ¿!', 'success');
            }).catch(err => {
                console.error('Failed to copy link: ', err);
                showMessage('Î‘Ï€Î¿Ï„Ï…Ï‡Î¯Î± Î±Î½Ï„Î¹Î³ÏÎ±Ï†Î®Ï‚. ÎŸ ÏƒÏÎ½Î´ÎµÏƒÎ¼Î¿Ï‚ ÎµÎ¯Î½Î±Î¹: ' + link, 'error');
            });
        }

        function parseUrlAndRestore() {
            const hash = window.location.hash.substring(1);
            if (!hash) return false;

            try {
                const decompressed = LZString.decompressFromEncodedURIComponent(hash);
                if (!decompressed || !decompressed.startsWith('v1|')) {
                    console.warn('Invalid or old share link format.');
                    return false;
                }

                const parts = decompressed.split('|');
                parts.shift(); // remove "v1"

                const showSteepHighlight = parts.pop() === 'true';
                const isRoundTrip = parts.pop() === 'true';

                const pins = parts.map(p => {
                    const coords = p.split(',');
                    // Return an object compatible with maptilersdk.LngLat
                    return { lat: parseFloat(coords[0]), lng: parseFloat(coords[1]) };
                });

                if (pins.length > 0) {
                    const snapshot = { 
                        pins: pins, 
                        isRoundTrip,
                        showSteepHighlight
                    };
                    state.history = [snapshot];
                    state.historyIndex = 0;
                    
                    // Wait for map to be loaded before restoring state
                    if (state.map.isStyleLoaded()) {
                        restoreState(snapshot);
                    } else {
                        state.map.once('load', () => restoreState(snapshot));
                    }
                    
                    console.log('Route restored from URL.');
                    return true;
                }
            } catch (e) {
                console.error("Failed to parse URL hash:", e);
                showMessage("ÎŸ ÏƒÏÎ½Î´ÎµÏƒÎ¼Î¿Ï‚ Ï„Î·Ï‚ Î´Î¹Î±Î´ÏÎ¿Î¼Î®Ï‚ ÎµÎ¯Î½Î±Î¹ ÎºÎ±Ï„ÎµÏƒÏ„ÏÎ±Î¼Î¼Î­Î½Î¿Ï‚.", 'error');
            }
            return false;
        }

        // --- GPX Import/Export ---
        function downloadGPX() {
            if (state.pins.length === 0) {
                showMessage('Î”ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ ÏƒÎ·Î¼ÎµÎ¯Î± Î³Î¹Î± ÎµÎ¾Î±Î³Ï‰Î³Î®.', 'error');
                return;
            }

            let gpx = `<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<gpx xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd" version="1.1" creator="WebApp Route Planner">
 <metadata>
  <name>Î”Î¹Î±Î´ÏÎ¿Î¼Î® Î±Ï€ÏŒ WebApp</name>
  <time>${new Date().toISOString()}</time>
 </metadata>
`;

            // Add waypoints (user pins)
            state.pins.forEach((pin, index) => {
                gpx += ` <wpt lat="${pin.lat}" lon="${pin.lng}">
  <name>Pin ${index + 1}</name>
 </wpt>
`;
            });

            // Add track if a route is calculated
            if (state.currentRoute && state.currentRoute.coordinates.length > 0) {
                gpx += ' <trk>\n  <name>Î¥Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼Î­Î½Î· Î”Î¹Î±Î´ÏÎ¿Î¼Î®</name>\n  <trkseg>\n';
                state.currentRoute.coordinates.forEach(coord => {
                    gpx += `   <trkpt lat="${coord[0]}" lon="${coord[1]}"><ele>${coord[2] || 0}</ele></trkpt>\n`;
                });
                gpx += '  </trkseg>\n </trk>\n';
            }

            gpx += '</gpx>';

            const blob = new Blob([gpx], { type: 'application/gpx+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `route_${new Date().toISOString().split('T')[0]}.gpx`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessage('Î— Î»Î®ÏˆÎ· Ï„Î¿Ï… GPX Î¾ÎµÎºÎ¯Î½Î·ÏƒÎµ.', 'success');
        }

        function handleGpxFileUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            if (!file.name.toLowerCase().endsWith('.gpx')) {
                showMessage('Î Î±ÏÎ±ÎºÎ±Î»Ï ÎµÏ€Î¹Î»Î­Î¾Ï„Îµ Î­Î½Î± Î±ÏÏ‡ÎµÎ¯Î¿ GPX (.gpx).', 'error');
                event.target.value = ''; // Reset file input
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const gpxContent = e.target.result;
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(gpxContent, "text/xml");

                    if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
                        throw new Error("ÎœÎ· Î­Î³ÎºÏ…ÏÎ· Î´Î¿Î¼Î® GPX.");
                    }

                    const waypoints = xmlDoc.querySelectorAll('wpt');
                    let newPins = [];

                    if (waypoints.length > 0) {
                        for (let i = 0; i < waypoints.length; i++) {
                            const lat = waypoints[i].getAttribute('lat');
                            const lon = waypoints[i].getAttribute('lon');
                            if (lat && lon) {
                                newPins.push(new maptilersdk.LngLat(parseFloat(lon), parseFloat(lat)));
                            }
                        }
                    }

                    if (newPins.length === 0) {
                        throw new Error("Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎ±Î½ Î±Ï€Î¿Î¸Î·ÎºÎµÏ…Î¼Î­Î½Î± pins (waypoints) ÏƒÏ„Î¿ Î±ÏÏ‡ÎµÎ¯Î¿ GPX.");
                    }
                    
                    if (newPins.length > CONFIG.MAX_PINS) {
                        showMessage(`Î¤Î¿ Î±ÏÏ‡ÎµÎ¯Î¿ Ï€ÎµÏÎ¹Î­Ï‡ÎµÎ¹ ${newPins.length} ÏƒÎ·Î¼ÎµÎ¯Î±. Î¦Î¿ÏÏ„ÏÎ¸Î·ÎºÎ±Î½ Ï„Î± Ï€ÏÏÏ„Î± ${CONFIG.MAX_PINS}.`, 'warning');
                        newPins = newPins.slice(0, CONFIG.MAX_PINS);
                    }

                    clearRoute(true); // Clear everything before loading
                    state.pins = newPins;
                    state.pinAddresses = state.pins.map(p => ({ status: 'empty', address: null, lngLat: p }));
                    state.pinAddresses.forEach((_, index) => fetchAddressForPin(index));

                    redrawFromState();
                    saveState();
                    showMessage(`Î— Î´Î¹Î±Î´ÏÎ¿Î¼Î® Î±Ï€ÏŒ Ï„Î¿ Î±ÏÏ‡ÎµÎ¯Î¿ GPX Ï†Î¿ÏÏ„ÏÎ¸Î·ÎºÎµ Î¼Îµ ${newPins.length} ÏƒÎ·Î¼ÎµÎ¯Î±.`, 'success');

                } catch (error) {
                    console.error("GPX parsing error:", error);
                    showMessage(`Î£Ï†Î¬Î»Î¼Î± ÎºÎ±Ï„Î¬ Ï„Î·Î½ ÎµÏ€ÎµÎ¾ÎµÏÎ³Î±ÏƒÎ¯Î± Ï„Î¿Ï… Î±ÏÏ‡ÎµÎ¯Î¿Ï… GPX: ${error.message}`, 'error');
                } finally {
                    event.target.value = '';
                }
            };
            reader.readAsText(file);
        }


        // --- MAP INTERACTION ---
        function handleMapClick(e) {
            // Prevent clicks when interacting with a marker
            if (e.originalEvent.target.closest('.maptiler-marker')) {
                return;
            }

            if (state.pins.length >= CONFIG.MAX_PINS) {
                showMessage(`Î•Ï€Î¹Ï„ÏÎ­Ï€Î¿Î½Ï„Î±Î¹ Î¼Î­Ï‡ÏÎ¹ ${CONFIG.MAX_PINS} ÏƒÎ·Î¼ÎµÎ¯Î±.`, 'error');
                return;
            }
            
            const latlng = e.lngLat;
            state.pins.push(latlng);
            state.pinAddresses.push({ status: 'empty', address: null, lngLat: latlng });
            fetchAddressForPin(state.pins.length - 1);

            addMarker(latlng, state.pins.length);
            
            if (state.pins.length >= 2) {
                calculateRoute();
            }
            saveState();
            updateUIState();
        }
        
        function handleMapRightClick(e) {
            e.preventDefault();
            
            rightClickLatLng = e.lngLat;
            // findBestWaypointInsertIndex will need refactoring to use LngLat
            insertIndex = findBestWaypointInsertIndex(rightClickLatLng);
            rightClickedPinIndex = -1; // Reset pin index

            const addWaypointBtn = document.getElementById('addWaypointBtn');
            const removePinBtn = document.getElementById('removePinBtn');
            addWaypointBtn.style.display = 'flex';
            removePinBtn.style.display = 'none';

            const contextMenu = document.getElementById('contextMenu');
            
            contextMenu.style.visibility = 'hidden';
            contextMenu.classList.remove('hidden');
            const menuWidth = contextMenu.offsetWidth;
            const menuHeight = contextMenu.offsetHeight;
            contextMenu.classList.add('hidden');
            contextMenu.style.visibility = 'visible';

            let x = e.originalEvent.clientX;
            let y = e.originalEvent.clientY;

            if (x + menuWidth > window.innerWidth) x = window.innerWidth - menuWidth - 10;
            if (y + menuHeight > window.innerHeight) y = window.innerHeight - menuHeight - 10;
            if (x < 0) x = 0;
            if (y < 0) y = 0;

            contextMenu.style.left = `${x}px`;
            contextMenu.style.top = `${y}px`;
            contextMenu.classList.remove('hidden');

            const hideMenu = (event) => {
                if (!contextMenu.contains(event.target) && event.button !== 2) {
                    contextMenu.classList.add('hidden');
                    document.removeEventListener('click', hideMenu);
                    document.removeEventListener('contextmenu', hideMenu);
                }
            };
            document.addEventListener('click', hideMenu);
            document.addEventListener('contextmenu', hideMenu);
        }

        function handleMarkerRightClick(e, markerIndex) {
            e.preventDefault();
            e.stopPropagation();

            rightClickedPinIndex = markerIndex;
            if (rightClickedPinIndex === -1) return;

            const addWaypointBtn = document.getElementById('addWaypointBtn');
            const removePinBtn = document.getElementById('removePinBtn');
            addWaypointBtn.style.display = 'none';
            removePinBtn.style.display = 'flex';

            const contextMenu = document.getElementById('contextMenu');
            
            contextMenu.style.visibility = 'hidden';
            contextMenu.classList.remove('hidden');
            const menuWidth = contextMenu.offsetWidth;
            const menuHeight = contextMenu.offsetHeight;
            contextMenu.classList.add('hidden');
            contextMenu.style.visibility = 'visible';

            let x = e.clientX;
            let y = e.clientY;

            if (x + menuWidth > window.innerWidth) x = window.innerWidth - menuWidth - 10;
            if (y + menuHeight > window.innerHeight) y = window.innerHeight - menuHeight - 10;
            if (x < 0) x = 0;
            if (y < 0) y = 0;

            contextMenu.style.left = `${x}px`;
            contextMenu.style.top = `${y}px`;
            contextMenu.classList.remove('hidden');

            const hideMenu = (event) => {
                if (!contextMenu.contains(event.target) && event.button !== 2) {
                    contextMenu.classList.add('hidden');
                    document.removeEventListener('click', hideMenu);
                    document.removeEventListener('contextmenu', hideMenu);
                }
            };
            document.addEventListener('click', hideMenu);
            document.addEventListener('contextmenu', hideMenu);
        }

        function addWaypoint(latlng, index) {
            if (state.pins.length >= CONFIG.MAX_PINS) {
                showMessage(`Î•Ï€Î¹Ï„ÏÎ­Ï€Î¿Î½Ï„Î±Î¹ Î¼Î­Ï‡ÏÎ¹ ${CONFIG.MAX_PINS} ÏƒÎ·Î¼ÎµÎ¯Î±.`, 'error');
                return;
            }

            state.pins.splice(index, 0, latlng);
            state.pinAddresses.splice(index, 0, { status: 'empty', address: null, lngLat: latlng });
            fetchAddressForPin(index);
            
            redrawFromState(); // Easiest way to re-number and re-draw everything
            saveState();
            updateUIState();
        }

        function addMarker(lngLat, number) {
            const el = createNumberedIcon(number, number === 1);
            
            const marker = new maptilersdk.Marker({element: el, draggable: true})
                .setLngLat(lngLat)
                .addTo(state.map);
            
            const index = state.markers.length; // Index before pushing
            
            marker.getElement().addEventListener('contextmenu', (e) => handleMarkerRightClick(e, index));

            marker.on('dragend', () => {
                const markerIndex = state.markers.indexOf(marker);
                if (markerIndex > -1) {
                    const newLngLat = marker.getLngLat();
                    state.pins[markerIndex] = newLngLat;
                    
                    // Update address state and refetch
                    if(state.pinAddresses[markerIndex]) {
                        state.pinAddresses[markerIndex].lngLat = newLngLat;
                        fetchAddressForPin(markerIndex, true); // Force refetch for new location
                    }

                    if (state.pins.length >= 2) calculateRoute();
                    saveState();
                }
            });
            
            state.markers.push(marker);
            updateFirstMarkerIcon();
        }

        function removePin(index) {
            if (index < 0 || index >= state.pins.length) return;
            
            state.markers[index].remove();
            state.pins.splice(index, 1);
            state.pinAddresses.splice(index, 1); // Remove address
            state.markers.splice(index, 1);
            
            renderAddressList(); // Update address list UI

            // Re-draw everything to update numbers correctly
            redrawFromState();
            saveState();
            updateUIState();
        }

        function createNumberedIcon(number, isStart = false) {
            const el = document.createElement('div');
            el.className = 'pin-icon';
            
            if (isStart) {
                el.classList.add('start');
                if (state.isRoundTrip && state.pins.length > 1) {
                    el.classList.add('flag');
                    el.innerHTML = 'ğŸ';
                } else {
                    el.innerHTML = number.toString();
                }
            } else {
                el.innerHTML = number.toString();
            }
            return el;
        }

        function updateFirstMarkerIcon() {
            if (state.markers.length > 0) {
                const firstMarker = state.markers[0];
                const el = firstMarker.getElement();
                const isRoundTrip = state.isRoundTrip && state.pins.length > 1;

                el.innerHTML = isRoundTrip ? 'ğŸ' : '1';
                el.classList.toggle('flag', isRoundTrip);
            }
        }

        function handleRoundTripToggle(e) {
            state.isRoundTrip = e.target.checked;
            updateFirstMarkerIcon();
            if (state.pins.length >= 2) {
                calculateRoute();
            } else if (!state.isRoundTrip) {
                clearRoute(false);
            }
            saveState();
        }

        function handleSteepUphillToggle(e) {
            state.showSteepHighlight = e.target.checked;
            if (state.map.isStyleLoaded() && state.map.getLayer('steepRouteLayer')) {
                state.map.setPaintProperty('steepRouteLayer', 'line-opacity', state.showSteepHighlight ? 0.8 : 0);
            }
            saveState();
        }
        
        // --- LOCATION SEARCH LOGIC ---
        function getConciseLocationName(item) {
            // MapTiler features have a 'text' property for the main name
            // and 'place_name' for the full address.
            // We prefer the 'text' property for a concise name.
            return item.text || item.place_name;
        }

        async function fetchSearchSuggestions(query) {
            const trimmedQuery = query.trim();
            if (!trimmedQuery) {
                clearSuggestions();
                setSearchLoading(false);
                return;
            }

            // Regex to detect "lat, lon" or "lat lon" patterns
            const coordRegex = /^\s*(-?\d{1,2}(\.\d+)?)\s*[, ]\s*(-?\d{1,3}(\.\d+)?)\s*$/;
            const match = trimmedQuery.match(coordRegex);

            if (match) {
                setSearchLoading(true);
                try {
                    const lat = parseFloat(match[1]);
                    const lon = parseFloat(match[3]);

                    // Validate coordinate ranges
                    if (lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
                        // Manually create a GeoJSON-like feature
                        const customFeature = {
                            id: 'custom-coordinate-' + Date.now(),
                            type: 'Feature',
                            place_name: `Î£Ï…Î½Ï„ÎµÏ„Î±Î³Î¼Î­Î½ÎµÏ‚: ${lat.toFixed(5)}, ${lon.toFixed(5)}`,
                            text: 'Î•Ï€Î¹Î»ÎµÎ³Î¼Î­Î½ÎµÏ‚ Î£Ï…Î½Ï„ÎµÏ„Î±Î³Î¼Î­Î½ÎµÏ‚',
                            center: [lon, lat],
                            geometry: {
                                type: 'Point',
                                coordinates: [lon, lat]
                            },
                            properties: {}
                        };
                        
                        state.searchSuggestions = [customFeature];
                        renderSuggestions([customFeature]);
                    } else {
                        clearSuggestions(); // Invalid coordinates
                    }
                } catch (e) {
                    clearSuggestions();
                } finally {
                    setSearchLoading(false);
                }
                return; // Stop here for coordinate input
            }


            // If not a coordinate, proceed with the text search
            try {
                // Construct the URL for MapTiler Geocoding API
                const proximity = state.map.getCenter();
                const proximityParam = `&proximity=${proximity.lng},${proximity.lat}`;
                const url = `https://api.maptiler.com/geocoding/${encodeURIComponent(trimmedQuery)}.json?key=${CONFIG.MAPTILER_API_KEY}&country=GR&language=el&limit=5${proximityParam}`;

                const response = await fetch(url);
                if (!response.ok) throw new Error('Î— Ï…Ï€Î·ÏÎµÏƒÎ¯Î± Î±Î½Î±Î¶Î®Ï„Î·ÏƒÎ·Ï‚ MapTiler Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î·.');
                
                const results = await response.json();

                if (!results || !results.features) throw new Error('Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎ±Î½ Î±Ï€Î¿Ï„ÎµÎ»Î­ÏƒÎ¼Î±Ï„Î±.');
                
                state.searchSuggestions = results.features;
                renderSuggestions(results.features);
            } catch (error) {
                console.error('Search error:', error);
                clearSuggestions();
            } finally {
                setSearchLoading(false);
            }
        }

        // MODIFIED: Added hover tooltips to search results
        function renderSuggestions(suggestions) {
            const suggestionsList = document.getElementById('search-suggestions');
            suggestionsList.innerHTML = '';
            suggestionsList.classList.remove('hidden');

            if (suggestions.length === 0) {
                suggestionsList.innerHTML = `<li class="text-gray-500 italic">Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎ±Î½ Î±Ï€Î¿Ï„ÎµÎ»Î­ÏƒÎ¼Î±Ï„Î±</li>`;
                return;
            }

            suggestions.forEach((item, index) => {
                const li = document.createElement('li');
                li.textContent = getConciseLocationName(item);
                li.dataset.index = index;
                li.addEventListener('click', () => selectSuggestion(item));
                
                // NEW: Add mouseenter and mouseleave events for the tooltip
                li.addEventListener('mouseenter', (e) => {
                    if (activeSearchTooltip) activeSearchTooltip.remove();

                    const currentItem = state.searchSuggestions[parseInt(e.currentTarget.dataset.index)];
                    if (!currentItem) return;

                    activeSearchTooltip = document.createElement('div');
                    activeSearchTooltip.className = 'search-result-tooltip';
                    activeSearchTooltip.innerHTML = currentItem.place_name;
                    document.body.appendChild(activeSearchTooltip);

                    const rect = e.currentTarget.getBoundingClientRect();
                    activeSearchTooltip.style.top = `${rect.top}px`;
                    activeSearchTooltip.style.left = `${rect.right + 10}px`;

                    const tooltipRect = activeSearchTooltip.getBoundingClientRect();
                    if (tooltipRect.right > window.innerWidth) {
                        activeSearchTooltip.style.left = `${rect.left - tooltipRect.width - 10}px`;
                    }
                    
                    setTimeout(() => {
                        if (activeSearchTooltip) activeSearchTooltip.style.opacity = '1';
                    }, 50);
                });

                li.addEventListener('mouseleave', () => {
                    if (activeSearchTooltip) {
                        activeSearchTooltip.style.opacity = '0';
                        setTimeout(() => {
                            if (activeSearchTooltip) activeSearchTooltip.remove();
                            activeSearchTooltip = null;
                        }, 200);
                    }
                });

                suggestionsList.appendChild(li);
            });
            state.highlightedSuggestionIndex = -1;
        }

        function selectSuggestion(item) {
            // item is a GeoJSON feature from MapTiler
            const lon = item.center[0];
            const lat = item.center[1];
            
            if (state.searchResultMarker) {
                state.searchResultMarker.remove();
            }
            
            state.map.flyTo({ center: [lon, lat], zoom: 15 });

            const popup = new maptilersdk.Popup({ offset: 25, closeButton: false })
                .setHTML(`<b>${item.place_name}</b>`); // Use place_name for the full address

            state.searchResultMarker = new maptilersdk.Marker({color: "#FF0000"})
              .setLngLat([lon, lat])
              .setPopup(popup)
              .addTo(state.map)
              .togglePopup();

            document.getElementById('search-input').value = getConciseLocationName(item);
            clearSuggestions();
        }

        function handleSearchKeyDown(e) {
            const suggestionsList = document.getElementById('search-suggestions');
            const items = suggestionsList.querySelectorAll('li');
            if (items.length === 0) return;

            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    state.highlightedSuggestionIndex = (state.highlightedSuggestionIndex + 1) % items.length;
                    updateSuggestionHighlight();
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    state.highlightedSuggestionIndex = (state.highlightedSuggestionIndex - 1 + items.length) % items.length;
                    updateSuggestionHighlight();
                    break;
                case 'Enter':
                    e.preventDefault();
                    if (state.highlightedSuggestionIndex > -1) {
                        selectSuggestion(state.searchSuggestions[state.highlightedSuggestionIndex]);
                    }
                    break;
                case 'Escape':
                    clearSuggestions();
                    break;
            }
        }

        function updateSuggestionHighlight() {
            const items = document.getElementById('search-suggestions').querySelectorAll('li');
            items.forEach((item, index) => {
                if (index === state.highlightedSuggestionIndex) {
                    item.classList.add('highlighted');
                    item.scrollIntoView({ block: 'nearest' });
                } else {
                    item.classList.remove('highlighted');
                }
            });
        }
        
        // MODIFIED: Cleans up the tooltip when suggestions are cleared
        function clearSuggestions() {
            const suggestionsList = document.getElementById('search-suggestions');
            suggestionsList.innerHTML = '';
            suggestionsList.classList.add('hidden');
            state.searchSuggestions = [];
            state.highlightedSuggestionIndex = -1;
            
            if (activeSearchTooltip) {
                activeSearchTooltip.remove();
                activeSearchTooltip = null;
            }
        }

        function setSearchLoading(isLoading) {
            state.isSearchLoading = isLoading;
            document.getElementById('search-spinner').classList.toggle('hidden', !isLoading);
            document.getElementById('search-magnifying-glass').classList.toggle('hidden', isLoading);
        }

        // --- OLD, CONFLICTING ADDRESS LOGIC REMOVED ---

        // --- ROUTE & ELEVATION CALCULATION ---
        async function calculateRoute() {
            let pinsForRoute = [...state.pins];
            if (state.isRoundTrip && pinsForRoute.length >= 2) {
                pinsForRoute.push(pinsForRoute[0]);
            }

            if (pinsForRoute.length < 2) {
                clearRoute(false);
                return;
            }
            
            showLoading(true);

            try {
                let routeData = null;
                const apis = [() => fetchFromORS(pinsForRoute), () => fetchFromGraphHopper(pinsForRoute)];

                for (const fetchFunc of apis) {
                    try {
                        routeData = await fetchFunc();
                        if (routeData) break;
                    } catch (error) {
                        console.warn(`${fetchFunc.name} failed:`, error.message);
                    }
                }

                if (!routeData) throw new Error('ÎŒÎ»ÎµÏ‚ Î¿Î¹ Ï…Ï€Î·ÏÎµÏƒÎ¯ÎµÏ‚ Î´ÏÎ¿Î¼Î¿Î»ÏŒÎ³Î·ÏƒÎ·Ï‚ Î±Ï€Î­Ï„Ï…Ï‡Î±Î½.');

                // More robust check for elevation data
                const hasInvalidElevation = !routeData.coordinates?.[0] || routeData.coordinates[0].length < 3 || typeof routeData.coordinates[0][2] !== 'number';

                if (hasInvalidElevation) {
                    console.log("Routing service did not provide valid elevation. Fetching separately...");
                    // Ensure coordinates are 2D before fetching elevation
                    const twoDCoords = routeData.coordinates.map(c => [c[0], c[1]]);
                    const elevations = await fetchElevationSeparately(twoDCoords);
                    
                    // Rebuild coordinates array with new elevations
                    routeData.coordinates = twoDCoords.map((coord, index) => {
                        return [coord[0], coord[1], elevations[index] || 0];
                    });
                }
                
                state.currentRoute = routeData;
                processElevationData(routeData.coordinates);

            } catch (error) {
                showMessage(error.message, 'error');
                console.error('Route calculation error:', error);
            } finally {
                showLoading(false);
            }
        }

        async function fetchFromORS(pins) {
            console.log("Attempting to fetch route from OpenRouteService...");
            const coordinates = pins.map(pin => [pin.lng, pin.lat]);
            const response = await fetch('https://api.openrouteservice.org/v2/directions/driving-car/geojson', {
                method: 'POST',
                headers: {
                    'Authorization': CONFIG.OPENROUTE_API_KEY,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    coordinates: coordinates,
                    instructions: false,
                    elevation: true
                })
            });

            if (!response.ok) throw new Error(`ORS API error: ${response.status}`);
            const data = await response.json();
            if (!data.features?.[0]) throw new Error('Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎµ Î´Î¹Î±Î´ÏÎ¿Î¼Î® Î±Ï€ÏŒ Ï„Î¿ ORS');
            
            const route = data.features[0];
            console.log("Success from OpenRouteService.");
            return {
                coordinates: route.geometry.coordinates.map(c => [c[1], c[0], c[2]]), // lat, lng, elevation
                distance: route.properties.summary?.distance || 0,
            };
        }

        async function fetchFromGraphHopper(pins) {
            console.log("Attempting to fetch route from GraphHopper...");
            const points = pins.map(pin => `point=${pin.lat},${pin.lng}`).join('&');
            const url = `https://graphhopper.com/api/1/route?${points}&vehicle=car&calc_points=true&points_encoded=false&type=json&key=${CONFIG.GRAPHHOPPER_KEY}`;
            
            const response = await fetch(url);
            if (!response.ok) throw new Error(`GraphHopper API error: ${response.status}`);
            const data = await response.json();
            if (!data.paths?.[0]) throw new Error('Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎµ Î´Î¹Î±Î´ÏÎ¿Î¼Î® Î±Ï€ÏŒ Ï„Î¿ GraphHopper');

            const path = data.paths[0];
            console.log("Success from GraphHopper.");
            return {
                coordinates: path.points.coordinates.map(c => [c[1], c[0]]), // lat, lng (no elevation)
                distance: path.distance,
            };
        }

        async function fetchElevationSeparately(coordinates) {
            const maxPoints = 300;
            let pointsToFetch = coordinates;
            if (coordinates.length > maxPoints) {
                pointsToFetch = [];
                const step = Math.floor(coordinates.length / maxPoints);
                for (let i = 0; i < coordinates.length; i += step) {
                    pointsToFetch.push(coordinates[i]);
                }
            }

            const response = await fetch(CONFIG.ELEVATION_API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    locations: pointsToFetch.map(c => ({ latitude: c[0], longitude: c[1] }))
                })
            });
            if (!response.ok) throw new Error('Elevation API failed');
            const data = await response.json();
            const elevations = data.results.map(r => r.elevation);

            if (coordinates.length > maxPoints) {
                const fullElevations = [];
                for(let i = 0; i < coordinates.length; i++) {
                    const step = Math.floor(coordinates.length / maxPoints);
                    const prevIndex = Math.floor(i / step);
                    const nextIndex = Math.min(prevIndex + 1, elevations.length - 1);
                    
                    if (prevIndex === nextIndex) {
                        fullElevations.push(elevations[prevIndex]);
                        continue;
                    }

                    const prevElev = elevations[prevIndex];
                    const nextElev = elevations[nextIndex];
                    const ratio = (i % step) / step;
                    fullElevations.push(prevElev + (nextElev - prevElev) * ratio);
                }
                return fullElevations;
            }
            return elevations;
        }
        
                        function processElevationData(routeCoordinates) {
                            let cumulativeDistance = 0;
                            let elevationGain = 0;
                            let steepUphillDistance = 0;
                            const elevationProfileData = [];
                            
                            routeCoordinates.forEach((point, index) => {
                                const elevation = point[2];
                                let isSteepSegment = false;
                                if (index > 0) {
                                    const prevPoint = routeCoordinates[index - 1];
                                    const segmentDistance = calculateHaversineDistance(prevPoint, point);
                                    cumulativeDistance += segmentDistance;
                
                                    const elevationDiff = elevation - (prevPoint[2] || 0);
                                    if (elevationDiff > 0) elevationGain += elevationDiff;
                
                                    // Check for steep uphill slope
                                    if (segmentDistance > 0) {
                                        const gradient = elevationDiff / segmentDistance;
                                        if (gradient > CONFIG.STEEP_GRADIENT_THRESHOLD) {
                                            isSteepSegment = true;
                                            if (elevationDiff > 0) { // Only count uphill steep segments
                                                steepUphillDistance += segmentDistance;
                                            }
                                        }
                                    }
                                }
                                elevationProfileData.push({ distance: cumulativeDistance, elevation: elevation, isSteep: isSteepSegment });
                            });
                
                            const maxChartPoints = 300;
                            let sampledElevationData = elevationProfileData;
                            let sampledRouteCoords = routeCoordinates;
                
                            if (elevationProfileData.length > maxChartPoints) {
                                sampledElevationData = [];
                                sampledRouteCoords = [];
                                const step = Math.floor(elevationProfileData.length / maxChartPoints);
                                for (let i = 0; i < elevationProfileData.length; i += step) {
                                    sampledElevationData.push(elevationProfileData[i]);
                                    sampledRouteCoords.push(routeCoordinates[i]);
                                }
                            }
                
                            state.currentElevation = { data: sampledElevationData, coordinates: sampledRouteCoords };
                
                            updateRouteStats({ distance: cumulativeDistance, elevationGain, steepUphillDistance });
                            displayColoredRoute(routeCoordinates);
                            displayElevationChart(sampledElevationData);
                            updateStatsVisibility(true);
                            showBottomPanel();
                        }        
                        // --- UI UPDATES & DISPLAY ---
                        function showBottomPanel() {
                            if (!state.currentRoute) return;
                            bottomPanel.classList.add('is-visible');
                            showPanelButton.classList.add('hidden');
                        }
                
                        function hideBottomPanel() {
                            bottomPanel.classList.remove('is-visible');
                            if (state.currentRoute) {
                                showPanelButton.classList.remove('hidden');
                            }
                        }
                
                        // Helper function to calculate bearing between two points
                        function getBearing(start, end) {
                            const startLng = start[0] * Math.PI / 180;
                            const startLat = start[1] * Math.PI / 180;
                            const endLng = end[0] * Math.PI / 180;
                            const endLat = end[1] * Math.PI / 180;

                            const y = Math.sin(endLng - startLng) * Math.cos(endLat);
                            const x = Math.cos(startLat) * Math.sin(endLat) - Math.sin(startLat) * Math.cos(endLat) * Math.cos(endLng - startLng);
                            const bearing = Math.atan2(y, x) * 180 / Math.PI;
                            return (bearing + 360) % 360;
                        }

                        // Helper function to get points along a line for arrows
                        function getArrowPoints(coordinates, spacing) {
                            if (coordinates.length < 2) return [];
                            
                            const arrowPoints = [];
                            let totalDistance = 0;
                            let distanceToNextArrow = spacing / 2; // Start halfway

                            for (let i = 0; i < coordinates.length - 1; i++) {
                                const start = coordinates[i];
                                const end = coordinates[i + 1];
                                const segmentDistance = haversineDistanceObjects({lng: start[0], lat: start[1]}, {lng: end[0], lat: end[1]});

                                while (totalDistance + segmentDistance >= distanceToNextArrow) {
                                    const distanceAlongSegment = distanceToNextArrow - totalDistance;
                                    const ratio = segmentDistance > 0 ? distanceAlongSegment / segmentDistance : 0;
                                    
                                    const pointLng = start[0] + (end[0] - start[0]) * ratio;
                                    const pointLat = start[1] + (end[1] - start[1]) * ratio;
                                    
                                    const bearing = getBearing(start, end);

                                    arrowPoints.push({
                                        type: 'Feature',
                                        geometry: {
                                            type: 'Point',
                                            coordinates: [pointLng, pointLat]
                                        },
                                        properties: {
                                            bearing: bearing
                                        }
                                    });
                                    distanceToNextArrow += spacing;
                                }
                                totalDistance += segmentDistance;
                            }
                            return arrowPoints;
                        }

                        function displayColoredRoute(routeCoordinates) {
                            if (!state.map.isStyleLoaded()) {
                                state.map.once('styledata', () => displayColoredRoute(routeCoordinates));
                                return;
                            }
                            // routeCoordinates are [lat, lng, ele]
                            // GeoJSON is [lng, lat]
                            const geojsonCoordinates = routeCoordinates.map(c => [c[1], c[0]]);

                            // 1. Update the main route source
                            const routeSource = state.map.getSource('routeSource');
                            if (routeSource) {
                                routeSource.setData({
                                    type: 'Feature',
                                    geometry: {
                                        type: 'LineString',
                                        coordinates: geojsonCoordinates
                                    }
                                });
                            }

                            // 2. Create and update the steep segments source
                            const steepSegments = [];
                            let currentSteepSegment = [];
                            for (let i = 1; i < routeCoordinates.length; i++) {
                                const startPoint = routeCoordinates[i - 1];
                                const endPoint = routeCoordinates[i];
                                const segmentDistance = calculateHaversineDistance(startPoint, endPoint);
                                const elevationDiff = endPoint[2] - startPoint[2];
                                
                                if (segmentDistance > 0) {
                                    const gradient = elevationDiff / segmentDistance;
                                    if (gradient > CONFIG.STEEP_GRADIENT_THRESHOLD && elevationDiff > 0) {
                                        if (currentSteepSegment.length === 0) {
                                            currentSteepSegment.push([startPoint[1], startPoint[0]]);
                                        }
                                        currentSteepSegment.push([endPoint[1], endPoint[0]]);
                                    } else {
                                        if (currentSteepSegment.length > 1) {
                                            steepSegments.push({
                                                type: 'Feature',
                                                properties: {},
                                                geometry: { type: 'LineString', coordinates: currentSteepSegment }
                                            });
                                        }
                                        currentSteepSegment = [];
                                    }
                                }
                            }
                            if (currentSteepSegment.length > 1) {
                                steepSegments.push({
                                    type: 'Feature',
                                    properties: {},
                                    geometry: { type: 'LineString', coordinates: currentSteepSegment }
                                });
                            }

                            const steepSource = state.map.getSource('steepRouteSource');
                            if (steepSource) {
                                steepSource.setData({
                                    type: 'FeatureCollection',
                                    features: steepSegments
                                });
                            }
                            
                            // 3. Set visibility of the steep layer
                            if (state.map.getLayer('steepRouteLayer')) {
                                state.map.setPaintProperty('steepRouteLayer', 'line-opacity', state.showSteepHighlight ? 0.8 : 0);
                            }

                            // 4. Handle route arrows
                            const arrowPoints = getArrowPoints(geojsonCoordinates, 400); // 400m spacing
                            const arrowsSource = state.map.getSource('routeArrowsSource');
                            if (arrowsSource) {
                                arrowsSource.setData({
                                    type: 'FeatureCollection',
                                    features: arrowPoints
                                });
                            }

                            // 5. Zoom map to fit the route
                            if (geojsonCoordinates.length > 0) {
                                const bounds = new maptilersdk.LngLatBounds(geojsonCoordinates[0], geojsonCoordinates[0]);
                                for (const coord of geojsonCoordinates) {
                                    bounds.extend(coord);
                                }
                                state.map.fitBounds(bounds, { padding: 80, duration: 1000 });
                            }
                        }
                
                        function updateRouteStats(data) {
                            const formatDistance = (d) => d > 1000 ? `${(d / 1000).toFixed(2)} km` : `${Math.round(d)} m`;
                            
                            document.getElementById('totalDistance').textContent = formatDistance(data.distance);
                            document.getElementById('steepUphillDistance').textContent = formatDistance(data.steepUphillDistance);
                            document.getElementById('elevationGain').textContent = `+${Math.round(data.elevationGain)} m`;
                        }
                        
                        async function displayElevationChart(elevationData) {
                            try {
                                await loadChartJs();
                            } catch {
                                showMessage('Î‘Ï€Î¿Ï„Ï…Ï‡Î¯Î± Ï†ÏŒÏÏ„Ï‰ÏƒÎ·Ï‚ Ï„Î¿Ï… Î³ÏÎ±Ï†Î®Î¼Î±Ï„Î¿Ï‚.', 'error');
                                return;
                            }
                
                            const ctx = document.getElementById('elevationChart').getContext('2d');
                            if (state.elevationChart) state.elevationChart.destroy();
                            document.getElementById('no-elevation-message').style.display = 'none';
                
                            const labels = elevationData.map(d => (d.distance / 1000).toFixed(2));
                            const elevations = elevationData.map(d => d.elevation);
                
                            state.elevationChart = new Chart(ctx, {
                                type: 'line',
                                data: {
                                    labels: labels,
                                    datasets: [{
                                        label: 'Î¥ÏˆÏŒÎ¼ÎµÏ„ÏÎ¿ (m)',
                                        data: elevations,
                                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                        borderWidth: 2,
                                        fill: true,
                                        pointRadius: 0,
                                        pointHoverRadius: 5,
                                        tension: 0.1,
                                        segment: {
                                            borderColor: ctx => {
                                                const index = ctx.p1DataIndex; // ctx.p1DataIndex refers to the end point of the segment
                                                const point = elevationData[index];
                                                return point && point.isSteep ? '#FF0000' : '#3B82F6';
                                            }
                                        }
                                    }]
                                },
                                options: {
                                    responsive: true, maintainAspectRatio: false,
                                    interaction: { intersect: false, mode: 'index' },
                                    scales: {
                                        x: { title: { display: true, text: 'Î‘Ï€ÏŒÏƒÏ„Î±ÏƒÎ· (km)' }, ticks: { autoSkip: true, maxTicksLimit: 10 } },
                                        y: { title: { display: true, text: 'Î¥ÏˆÏŒÎ¼ÎµÏ„ÏÎ¿ (m)' } }
                                    },
                                    plugins: {
                                        legend: { display: false },
                                        tooltip: {
                                            callbacks: {
                                                title: (ctx) => `Î‘Ï€ÏŒÏƒÏ„Î±ÏƒÎ·: ${ctx[0].label} km`,
                                                label: (ctx) => `Î¥ÏˆÏŒÎ¼ÎµÏ„ÏÎ¿: ${Math.round(ctx.raw)} m`
                                            }
                                        }
                                    },
                                    onHover: (event, chartElement) => {
                                        if (chartElement.length > 0) {
                                            const index = chartElement[0].index;
                                            const coord = state.currentElevation.coordinates[index];
                                            if (coord) {
                                                const lngLat = [coord[1], coord[0]]; // MapTiler is Lng, Lat
                                                if (!state.highlightMarker) {
                                                    // Use a blue marker that matches the app's theme
                                                    state.highlightMarker = new maptilersdk.Marker({ color: '#3B82F6' })
                                                        .setLngLat(lngLat)
                                                        .addTo(state.map);
                                                } else {
                                                    state.highlightMarker.setLngLat(lngLat);
                                                }
                                            }
                                        } else if (state.highlightMarker) {
                                            state.highlightMarker.remove();
                                            state.highlightMarker = null;
                                        }
                                    }
                                }
                            });
                

                        }
                        
                        // --- UTILITY & HELPER FUNCTIONS ---
                        function clearRoute(clearPins) {
                            if (clearPins) {
                                state.markers.forEach(marker => marker.remove());
                                state.markers = [];
                                state.pins = [];
                                document.getElementById('roundTripToggle').checked = false;
                                state.isRoundTrip = false;
                                document.getElementById('steepUphillToggle').checked = false;
                                state.showSteepHighlight = false;
                                
                                state.history = [];
                                state.historyIndex = -1;
                                saveState();
                            }
                            
                            // Clear the route data from the map sources
                            if (state.map.isStyleLoaded()) {
                                const routeSource = state.map.getSource('routeSource');
                                if (routeSource) routeSource.setData({ type: 'Feature', geometry: null });
                                
                                const steepSource = state.map.getSource('steepRouteSource');
                                if (steepSource) steepSource.setData({ type: 'FeatureCollection', features: [] });

                                const arrowsSource = state.map.getSource('routeArrowsSource');
                                if (arrowsSource) arrowsSource.setData({ type: 'FeatureCollection', features: [] });
                            }
                            
                            if (state.elevationChart) {
                                state.elevationChart.destroy();
                                state.elevationChart = null;
                            }
                            if (state.highlightMarker) {
                                state.highlightMarker.remove();
                                state.highlightMarker = null;
                            }
                            if (state.searchResultMarker) {
                                state.searchResultMarker.remove();
                                state.searchResultMarker = null;
                            }
                            
                            state.currentRoute = null;
                            state.currentElevation = { data: [], coordinates: [] };
                            
                            hideBottomPanel();
                            updateStatsVisibility(false);
                            document.getElementById('no-elevation-message').style.display = 'flex';
                            updateUIState();
                        }
                
                
                        
                        function generateGPX(route) {
                            const timestamp = new Date().toISOString();
                            let gpx = `<?xml version="1.0" encoding="UTF-8"?>
                <gpx version="1.1" creator="Route Planner" xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">
                  <metadata><time>${timestamp}</time></metadata>
                  <trk><name>Planned Route</name><trkseg>`;
                            
                            route.coordinates.forEach(coord => {
                                gpx += `\n      <trkpt lat="${coord[0]}" lon="${coord[1]}"><ele>${coord[2] || 0}</ele></trkpt>`;
                            });
                            
                            gpx += `\n    </trkseg></trk></gpx>`;
                            return gpx;
                        }
                
                        function calculateHaversineDistance(coords1, coords2) {
                            const R = 6371e3; // metres
                            const Ï†1 = coords1[0] * Math.PI/180;
                            const Ï†2 = coords2[0] * Math.PI/180;
                            const Î”Ï† = (coords2[0]-coords1[0]) * Math.PI/180;
                            const Î”Î» = (coords2[1]-coords1[1]) * Math.PI/180;
                
                            const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) + Math.cos(Ï†1) * Math.cos(Ï†2) * Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
                            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                            return R * c;
                        }

                        function haversineDistanceObjects(lngLat1, lngLat2) {
                            const R = 6371e3; // metres
                            const Ï†1 = lngLat1.lat * Math.PI / 180;
                            const Ï†2 = lngLat2.lat * Math.PI / 180;
                            const Î”Ï† = (lngLat2.lat - lngLat1.lat) * Math.PI / 180;
                            const Î”Î» = (lngLat2.lng - lngLat1.lng) * Math.PI / 180;

                            const a = Math.sin(Î”Ï† / 2) * Math.sin(Î”Ï† / 2) +
                                      Math.cos(Ï†1) * Math.cos(Ï†2) *
                                      Math.sin(Î”Î» / 2) * Math.sin(Î”Î» / 2);
                            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

                            return R * c; // in metres
                        }
                
                        // Re-implemented to remove Leaflet dependencies
                        function findBestWaypointInsertIndex(newLatLng) {
                            if (state.pins.length < 2) {
                                return state.pins.length;
                            }
                
                            let minDistance = Infinity;
                            let bestIndex = state.pins.length;
                
                            for (let i = 0; i < state.pins.length - 1; i++) {
                                const p1 = state.pins[i];
                                const p2 = state.pins[i + 1];
                
                                // Midpoint approximation
                                const midPoint = new maptilersdk.LngLat((p1.lng + p2.lng) / 2, (p1.lat + p2.lat) / 2);
                                const distance = haversineDistanceObjects(newLatLng, midPoint);

                                if (distance < minDistance) {
                                    minDistance = distance;
                                    bestIndex = i + 1; // Insert after p1
                                }
                            }
                            return bestIndex;
                        }
                        
                        function debounce(func, delay) {            let timeout;
            const debounced = function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
            debounced.cancel = () => clearTimeout(timeout);
            return debounced;
        }

        function loadChartJs() {
            return new Promise((resolve, reject) => {
                if (state.isChartJsLoaded) {
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js';
                script.onload = () => {
                    state.isChartJsLoaded = true;
                    console.log('Chart.js loaded dynamically.');
                    resolve();
                };
                script.onerror = () => {
                    console.error('Failed to load Chart.js');
                    reject(new Error('Failed to load Chart.js'));
                };
                document.head.appendChild(script);
            });
        }



        function showLoading(show) {
            document.getElementById('topRightLoader').classList.toggle('hidden', !show);
        }
        
        function showMessage(message, type = 'error') {
            const el = document.getElementById('messageOverlay');
            document.getElementById('messageText').textContent = message;
            
            el.className = 'absolute top-24 left-1/2 transform -translate-x-1/2 px-4 py-3 rounded-md shadow-lg z-[4000]';
            if (type === 'error') {
                el.classList.add('bg-red-100', 'border', 'border-red-400', 'text-red-700');
            } else { // success
                el.classList.add('bg-green-100', 'border', 'border-green-400', 'text-green-700');
            }

            el.style.display = 'block';
            el.classList.remove('message-fade');
            setTimeout(() => el.classList.add('message-fade'), 4500);
        }
        
        function updateUIState() {
            const hasPins = state.pins.length > 0;
            const hasRoute = state.pins.length >= 2;
            
            document.getElementById('instructions').style.display = hasPins ? 'none' : 'block';
            document.getElementById('downloadGPX').style.display = hasRoute ? 'flex' : 'none';
            document.getElementById('downloadPDF').style.display = hasRoute ? 'flex' : 'none';
            document.getElementById('shareButton').disabled = !hasPins;
            showPanelButton.classList.toggle('hidden', !hasRoute || bottomPanel.classList.contains('is-visible'));
            updateUndoButton();
        }
        
        function updateUndoButton() {
            document.getElementById('undoButton').disabled = state.historyIndex <= 0;
        }

        function updateStatsVisibility(show) {
            document.getElementById('stats-content').classList.toggle('hidden', !show);
            document.getElementById('no-stats-message').classList.toggle('hidden', show);
        }
    </script>
</body>
</html>